'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});

const isMethod = require('./helpers/isMethod.cjs');

function hasher(...args) {
  return JSON.stringify(args);
}

function createMemoizer(method, rootCache, options) {
  // Must be a normal function as we require `this`
  return function memoizer(...args) {
    // Extract the cache for this specific instance
    let cache = rootCache.get(this);

    if (!cache) {
      cache = options.cache ? new Map(options.cache) : new Map();
      rootCache.set(this, cache);
    } // Hash the key and check the cache


    const key = options.hasher(...args);
    const item = cache.get(key);

    if (item && (!item.time || typeof item.time === 'number' && item.time > Date.now())) {
      return item.value;
    } // No cache so execute and cache the result


    const value = method.apply(this, args);
    const time = options.expires > 0 ? Date.now() + options.expires : null;
    cache.set(key, {
      time,
      value
    }); // Only cache if successful

    if (value instanceof Promise) {
      // eslint-disable-next-line promise/prefer-await-to-then
      value.catch(() => cache?.delete(key));
    }

    return value;
  };
}
/**
 * A method decorator that caches the return value of a class method or
 * getter to consistently and efficiently return the same value.
 */


function Memoize(options = {}) {
  // eslint-disable-next-line complexity
  return (target, property, descriptor) => {
    if (process.env.NODE_ENV !== "production" && (!isMethod.isMethod(target, property, descriptor) || !('value' in descriptor && typeof descriptor.value === 'function') && !('get' in descriptor && typeof descriptor.get === 'function'))) {
      throw new TypeError(`\`@Memoize\` may only be applied to class methods or getters.`);
    }

    const config = _objectSpread({
      cache: null,
      expires: 0,
      hasher
    }, typeof options === 'function' ? {
      hasher: options
    } : options);

    if (process.env.NODE_ENV !== "production") {
      if (config.cache && !(config.cache instanceof Map)) {
        throw new Error('`cache` must be an instance of `Map`.');
      }

      if (typeof config.expires !== 'number' || config.expires < 0) {
        throw new Error('`expires` must be a number greater than or equal to 0.');
      }

      if (typeof config.hasher !== 'function') {
        throw new TypeError('`hasher` must be a function.');
      }
    } // We must use a map as all class instances would share the
    // same cache otherwise. Probability of collision is high.


    const rootCache = new WeakMap();

    if (descriptor.get) {
      // @ts-expect-error Override generic
      descriptor.get = createMemoizer(descriptor.get, rootCache, config);
    } else if (descriptor.value) {
      // @ts-expect-error Override generic
      descriptor.value = createMemoizer(descriptor.value, rootCache, config);
    }
  };
}

exports.Memoize = Memoize;
//# sourceMappingURL=Memoize.cjs.map
