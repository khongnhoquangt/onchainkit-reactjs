'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const minimatch = require('minimatch');
const common = require('@boost/common');
const internal = require('@boost/internal');
const ConfigError = require('./ConfigError.cjs');
const constants = require('./constants.cjs');
const Finder = require('./Finder.cjs');
const createFileName = require('./helpers/createFileName.cjs');
const getEnv = require('./helpers/getEnv.cjs');
const cjs = require('./loaders/cjs.cjs');
const js = require('./loaders/js.cjs');
const json = require('./loaders/json.cjs');
const mjs = require('./loaders/mjs.cjs');
const ts = require('./loaders/ts.cjs');
const yaml = require('./loaders/yaml.cjs');

/* eslint-disable no-param-reassign, no-await-in-loop */
class ConfigFinder extends Finder.Finder {
  blueprint(schemas) {
    const array = schemas.array,
      bool = schemas.bool,
      func = schemas.func,
      shape = schemas.shape,
      string = schemas.string;
    return {
      errorIfNoRootFound: bool(true),
      extendsSetting: string(),
      extensions: array(constants.DEFAULT_EXTS).of(string()),
      includeEnv: bool(true),
      loaders: shape({
        cjs: func(() => cjs.loadCjs).notNullable(),
        js: func(() => js.loadJs).notNullable(),
        json: func(() => json.loadJson).notNullable(),
        json5: func(() => json.loadJson).notNullable(),
        mjs: func(() => mjs.loadMjs).notNullable(),
        ts: func(() => ts.loadTs).notNullable(),
        yaml: func(() => yaml.loadYaml).notNullable(),
        yml: func(() => yaml.loadYaml).notNullable()
      }).exact(),
      name: string().required().camelCase(),
      overridesSetting: string(),
      resolver: func(() => common.PathResolver.defaultResolver).notNullable()
    };
  }

  /**
   * Determine a files package scope by finding the first parent `package.json`
   * when traversing up directories. We will leverage the cache as much as
   * possible for performance.
   *
   * @see https://nodejs.org/api/esm.html#esm_package_scope_and_file_extensions
   */
  async determinePackageScope(dir) {
    let currentDir = dir.isDirectory() ? dir : dir.parent();
    this.debug('Determining package scope for %s', internal.color.filePath(dir.path()));
    while (!this.isFileSystemRoot(currentDir)) {
      const pkgPath = currentDir.append(constants.PACKAGE_FILE);
      const cache = this.cache.getFileCache(pkgPath);
      if (cache) {
        if (cache.exists) {
          this.debug('Scope found at %s', internal.color.filePath(pkgPath.path()));
          return cache.content;
        }

        // Fall-through
      } else if (pkgPath.exists()) {
        this.debug('Scope found at %s', internal.color.filePath(pkgPath.path()));
        return this.cache.cacheFileContents(pkgPath, () => json.loadJson(pkgPath));
      } else {
        this.cache.markMissingFile(pkgPath);
      }
      currentDir = currentDir.parent();
    }
    throw new ConfigError.ConfigError('PACKAGE_UNKNOWN_SCOPE');
  }

  /**
   * Find all configuration and environment specific files in a directory
   * by looping through all the defined extension options.
   * Will only search until the first file is found, and will not return multiple extensions.
   */
  async findFilesInDir(dir) {
    const _this$options = this.options,
      extensions = _this$options.extensions,
      includeEnv = _this$options.includeEnv;
    const isRoot = this.isRootDir(dir);
    const hash = isRoot ? '#root' : '#branch';
    return this.cache.cacheFilesInDir(dir, hash, async () => {
      const paths = [];
      for (const ext of extensions) {
        const files = [];
        if (isRoot) {
          files.push(dir.append(this.getFileName('root-file', ext, false)), includeEnv && dir.append(this.getFileName('root-file', ext, true)), dir.append(this.getFileName('root-folder', ext, false)), includeEnv && dir.append(this.getFileName('root-folder', ext, true)));
        } else {
          files.push(dir.append(this.getFileName('branch', ext, false)), includeEnv && dir.append(this.getFileName('branch', ext, true)));
        }
        await Promise.all(files.filter(Boolean).map(configPath => {
          if (configPath.exists()) {
            paths.push(configPath);
          }
          return configPath;
        }));

        // Once we find any file, we abort looking for others
        if (paths.length > 0) {
          break;
        }
      }
      this.debug.invariant(paths.length > 0, `Finding config files in ${internal.color.filePath(dir.path())}`, paths.map(path => path.name()).join(', '), 'No files');

      // Make sure env takes higher precedence
      paths.sort((a, b) => a.path().length - b.path().length);
      return paths;
    });
  }

  /**
   * Create and return a config file name, with optional branch and environment variants.
   */
  getFileName(type, ext, isEnv) {
    const name = this.options.name;
    return createFileName.createFileName(type, name, ext, isEnv ? getEnv.getEnv(name) : '');
  }

  /**
   * Load file and package contents from a list of file paths.
   * Extract and apply extended and override configs based on the base path.
   */
  async resolveFiles(basePath, foundFiles) {
    this.debug('Resolving %d config files', foundFiles.length);
    const configs = await Promise.all(foundFiles.map(filePath => this.loadConfig(filePath)));

    // Overrides take the highest precedence and must appear after everything,
    // including branch level configs. However, they must extract first so that
    // extends functionality can be inherited (below).
    if (this.options.overridesSetting) {
      const overriddenConfigs = await this.extractOverriddenConfigs(basePath, configs);
      this.debug('Overriding %d configs', overriddenConfigs.length);
      if (overriddenConfigs.length > 0) {
        configs.push(...overriddenConfigs);
      }
    }

    // Configs that have been extended from root configs must
    // appear before everything else, in the order they were defined
    if (this.options.extendsSetting) {
      const extendedConfigs = await this.extractExtendedConfigs(configs);
      this.debug('Extending %d configs', extendedConfigs.length);
      if (extendedConfigs.length > 0) {
        configs.unshift(...extendedConfigs);
      }
    }
    return configs;
  }

  /**
   * Extract a list of config files to extend, in order, from the list of previously loaded
   * config files, which is typically from the root. The list to extract can be located within
   * a property that matches the `extendsSetting` option.
   */
  async extractExtendedConfigs(configs) {
    const _this$options2 = this.options,
      name = _this$options2.name,
      extendsSetting = _this$options2.extendsSetting,
      resolver = _this$options2.resolver;
    const extendsPaths = [];
    this.debug('Extracting configs to extend from');
    for (const _ref of configs) {
      const config = _ref.config;
      const path = _ref.path;
      const source = _ref.source;
      const key = extendsSetting;
      const extendsFrom = config[key];
      if (source === 'root' || source === 'overridden') {
        delete config[key];
      } else if (extendsFrom) {
        throw new ConfigError.ConfigError('EXTENDS_ONLY_ROOT', [key]);
      } else {
        // eslint-disable-next-line no-continue
        continue;
      }
      const extendedPaths = await Promise.all(common.toArray(extendsFrom).map(async extendsPath => {
        // Node module
        if (common.isModuleName(extendsPath)) {
          const modulePath = new common.Path(extendsPath, createFileName.createFileName('preset', name, 'js', 'preset'));
          this.debug('Extending config from node module: %s', internal.color.moduleName(modulePath.path()));
          return new common.Path(await resolver(modulePath.path()));
        }

        // File path
        if (common.isFilePath(extendsPath)) {
          let filePath = new common.Path(extendsPath);

          // Relative to the config file its defined in
          if (!filePath.isAbsolute()) {
            filePath = path.parent().append(extendsPath);
          }
          this.debug('Extending config from file path: %s', internal.color.filePath(filePath.path()));
          return filePath;
        }

        // Unknown
        throw new ConfigError.ConfigError('EXTENDS_UNKNOWN_PATH', [extendsPath]);
      }));
      extendsPaths.push(...extendedPaths);
    }
    return Promise.all(extendsPaths.map(path => this.loadConfig(path, 'extended')));
  }

  /**
   * Extract all root config overrides that match the current path used to load with.
   * Overrides are located within a property that matches the `overridesSetting` option.
   */
  extractOverriddenConfigs(basePath, configs) {
    const overridesSetting = this.options.overridesSetting;
    const overriddenConfigs = [];
    this.debug('Extracting configs to override with (matching against %s)', internal.color.filePath(basePath.path()));
    configs.forEach(({
      config,
      path,
      source
    }) => {
      const key = overridesSetting;
      const overrides = config[key];
      if (source === 'root') {
        delete config[key];
      } else if (overrides) {
        throw new ConfigError.ConfigError('ROOT_ONLY_OVERRIDES', [key]);
      } else {
        return;
      }
      common.toArray(overrides).forEach(({
        exclude,
        include,
        settings
      }) => {
        const options = {
          dot: true,
          matchBase: true
        };
        const excludePatterns = common.toArray(exclude);
        const excluded = excludePatterns.some(pattern => minimatch.minimatch(basePath.path(), pattern, options));
        const includePatterns = common.toArray(include);
        const included = includePatterns.some(pattern => minimatch.minimatch(basePath.path(), pattern, options));
        const passes = included && !excluded;
        this.debug.invariant(passes, `Matching with includes "${includePatterns}" and excludes "${excludePatterns}"`, 'Matched',
        // eslint-disable-next-line no-nested-ternary
        excluded ? 'Excluded' : included ? 'Not matched' : 'Not included');
        if (passes) {
          overriddenConfigs.push({
            config: settings,
            path,
            source: 'overridden'
          });
        }
      });
    });
    return overriddenConfigs;
  }

  /**
   * Load config contents from the provided file path using one of the defined loaders.
   */
  async loadConfig(path, source) {
    const pkg = await this.determinePackageScope(path);
    const config = await this.cache.cacheFileContents(path, async () => {
      const loaders = this.options.loaders;
      const ext = path.ext(true);
      this.debug('Loading config %s with type %s', internal.color.filePath(path.path()), internal.color.symbol(ext));
      switch (ext) {
        case 'cjs':
          return loaders.cjs(path, pkg);
        case 'js':
          return loaders.js(path, pkg);
        case 'json':
        case 'json5':
          return loaders.json(path, pkg);
        case 'mjs':
          // Not easily testable yet
          // istanbul ignore next
          return loaders.mjs(path, pkg);
        case 'ts':
        case 'tsx':
          return loaders.ts(path, pkg);
        case 'yaml':
        case 'yml':
          return loaders.yaml(path, pkg);
        default:
          throw new ConfigError.ConfigError('LOADER_UNSUPPORTED', [ext]);
      }
    });
    const isRoot = constants.ROOT_CONFIG_DIR_REGEX.test(path.path()) || constants.ROOT_CONFIG_FILE_REGEX.test(path.path());
    return {
      config,
      path,
      source: source ?? (isRoot ? 'root' : 'branch')
    };
  }
}
exports.ConfigFinder = ConfigFinder;
//# sourceMappingURL=ConfigFinder.cjs.map
