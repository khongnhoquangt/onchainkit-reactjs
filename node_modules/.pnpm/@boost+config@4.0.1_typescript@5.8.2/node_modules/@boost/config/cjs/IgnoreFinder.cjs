'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const fs = require('fs');
const internal = require('@boost/internal');
const Finder = require('./Finder.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const fs__default = /*#__PURE__*/_interopDefault(fs);
class IgnoreFinder extends Finder.Finder {
  blueprint(schemas) {
    const bool = schemas.bool,
      string = schemas.string;
    return {
      errorIfNoRootFound: bool(true),
      name: string().required().camelCase()
    };
  }

  /**
   * Find a single ignore file in the provided directory.
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async findFilesInDir(dir) {
    const files = [];
    const path = dir.append(this.getFileName());
    if (path.exists()) {
      files.push(path);
    }
    this.debug.invariant(files.length > 0, `Finding ignore files in ${internal.color.filePath(dir.path())}`, files.map(file => file.name()).join(', '), 'No files');
    return files;
  }

  /**
   * Return an ignore specific file.
   */
  getFileName() {
    return `.${this.options.name.toLowerCase()}ignore`;
  }

  /**
   * Load and parse a list of found files into a list of ignore patterns.
   */
  async resolveFiles(basePath, foundFiles) {
    this.debug('Resolving %d ignore files', foundFiles.length);
    return Promise.all(foundFiles.map(async filePath => {
      const contents = await this.cache.cacheFileContents(filePath, () => fs__default.default.promises.readFile(filePath.path(), 'utf8'));
      const ignore = contents.split('\n').map(line => line.trim()).filter(line => line !== '' && !line.startsWith('#'));
      return {
        ignore,
        path: filePath,
        source: this.isRootDir(filePath.parent()) ? 'root' : 'branch'
      };
    }));
  }
}
exports.IgnoreFinder = IgnoreFinder;
//# sourceMappingURL=IgnoreFinder.cjs.map
