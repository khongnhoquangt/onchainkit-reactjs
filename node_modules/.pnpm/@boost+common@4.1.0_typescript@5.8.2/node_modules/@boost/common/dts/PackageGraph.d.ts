import { PackageGraphTree, PackageStructure } from './types';
declare class Node {
    name: string;
    dependents: Set<Node>;
    requirements: Set<Node>;
    constructor(name: string);
}
export declare class PackageGraph<T extends PackageStructure = PackageStructure> {
    protected mapped: boolean;
    protected nodes: Map<string, Node>;
    protected packages: Map<string, T>;
    constructor(packages?: T[]);
    /**
     * Add a package by name with an associated `package.json` object.
     * Will map a dependency between the package and its dependees
     * found in `dependencies` and `peerDependencies`.
     */
    addPackage(pkg: T): this;
    /**
     * Add multiple packages.
     */
    addPackages(packages?: T[]): this;
    /**
     * Resolve the dependency graph and return a list of all
     * `package.json` objects in the order they are depended on.
     *
     * ```ts
     * graph.resolveList().forEach((pkg) => {
     * 	console.log(pkg.name);
     * });
     * ```
     */
    resolveList(): T[];
    /**
     * Resolve the dependency graph and return a tree of nodes for all
     * `package.json` objects and their dependency mappings.
     *
     * ```ts
     * graph.resolveTree().nodes.forEach((node) => {
     * 	console.log(node.package.name);
     *
     * 	if (node.nodes) {
     * 		// Dependents
     * 	}
     * });
     * ```
     */
    resolveTree(): PackageGraphTree<T>;
    /**
     * Resolve the dependency graph and return a list of batched `package.json` objects
     * (array of arrays) in the order they are depended on.
     *
     * ```ts
     * graph.resolveBatchList().forEach((pkgs) => {
     * 	pkgs.forEach((pkg) => {
     * 		console.log(pkg.name);
     * 	});
     * });
     * ```
     */
    resolveBatchList(): T[][];
    /**
     * Add a node for the defined package name.
     */
    protected addNode(name: string): void;
    /**
     * Dig through all nodes and attempt to find a circular dependency cycle.
     */
    protected detectCycle(): void;
    /**
     * Return all nodes that can be considered "root",
     * as determined by having no requirements.
     */
    protected getRootNodes(): Node[];
    /**
     * Map dependencies between all currently registered packages.
     */
    protected mapDependencies(): void;
    /**
     * Map a dependency link for a dependent (child) depending on a requirement (parent).
     * Will link the parent and child accordingly, and will remove the child
     * from the root if it exists.
     */
    protected mapDependency(dependentName: string, requirementName: string): void;
    /**
     * Remove all current nodes in the graph and add new root nodes for each package.
     */
    protected resetNodes(): void;
    /**
     * Sort a set of nodes by most depended on, fall back to alpha sort as tie breaker
     */
    protected sortByDependedOn(nodes: Node[] | Set<Node>): Node[];
}
export {};
//# sourceMappingURL=PackageGraph.d.ts.map