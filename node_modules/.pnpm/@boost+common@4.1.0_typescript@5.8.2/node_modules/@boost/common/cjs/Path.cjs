'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const fs = require('fs');
const path = require('path');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const fs__default = /*#__PURE__*/_interopDefault(fs);
const path__default = /*#__PURE__*/_interopDefault(path);

/**
 * An immutable class for operating on file system paths.
 * Will normalize path separators based on the operating system,
 * "/" on Linux/MacOS, and "\\" on Windows.
 */
class Path {
  constructor(...parts) {
    this.internalPath = '';
    this.isNormalized = false;
    this.internalPath = path__default.default.join(...parts.map(String));
  }

  /**
   * Create and return a new `Path` instance.
   */
  static create(filePath) {
    return new Path(filePath);
  }

  /**
   * Convert a path-like value to a formatted path string.
   */
  static path(part) {
    return new Path(part).path();
  }

  /**
   * Like `create()` but also resolves the path against a working directory.
   */
  static resolve(filePath, cwd) {
    return Path.create(filePath).resolve(cwd);
  }

  /**
   * Append path parts to the end of the current path
   * and return a new `Path` instance.
   */
  append(...parts) {
    return new Path(this.internalPath, ...parts);
  }

  /**
   * Returns true if both paths are equal using strict equality.
   */
  equals(filePath) {
    return this.path() === Path.create(filePath).path();
  }

  /**
   * Return the extension (if applicable) with or without leading period.
   */
  ext(withoutPeriod = false) {
    const ext = path__default.default.extname(this.path());
    return withoutPeriod && ext.startsWith('.') ? ext.slice(1) : ext;
  }

  /**
   * Return true if the current path exists.
   */
  exists() {
    return fs__default.default.existsSync(this.path());
  }

  /**
   * Return true if the current path is absolute.
   */
  isAbsolute() {
    return path__default.default.isAbsolute(this.path());
  }

  /**
   * Return true if the current path is a folder.
   */
  isDirectory() {
    return fs__default.default.statSync(this.path()).isDirectory();
  }

  /**
   * Return true if the current path is a file.
   */
  isFile() {
    return fs__default.default.statSync(this.path()).isFile();
  }

  /**
   * Return the file name (with optional extension) or folder name.
   */
  name(withoutExtension = false) {
    let name = path__default.default.basename(this.path());
    if (withoutExtension) {
      name = name.replace(this.ext(), '');
    }
    return name;
  }

  /**
   * Return the parent folder as a new `Path` instance.
   */
  parent() {
    return new Path(path__default.default.dirname(this.internalPath));
  }

  /**
   * Return the current path as a normalized string.
   */
  path() {
    if (!this.isNormalized) {
      this.isNormalized = true;
      this.internalPath = path__default.default.normalize(this.internalPath);
    }
    return this.internalPath;
  }

  /**
   * Prepend path parts to the beginning of the current path
   * and return a new `Path` instance.
   */
  prepend(...parts) {
    return new Path(...parts, this.internalPath);
  }

  /**
   * Returns a canonical path by resolving directories and symlinks.
   */
  // istanbul ignore next
  realPath() {
    return fs__default.default.realpathSync.native(this.path());
  }

  /**
   * Return a new relative `Path` instance from the current
   * "from" path to the defined "to" path.
   */
  relativeTo(to) {
    return new Path(path__default.default.relative(this.internalPath, String(to)));
  }

  /**
   * Return a new `Path` instance where the current path is accurately
   * resolved against the defined working directory.
   */
  resolve(cwd) {
    return new Path(path__default.default.resolve(String(cwd ?? process.cwd()), this.internalPath));
  }
  toJSON() {
    return this.path();
  }
  toString() {
    return this.path();
  }
}
Path.DELIMITER = path__default.default.delimiter;
Path.SEP = path__default.default.sep;
exports.Path = Path;
//# sourceMappingURL=Path.cjs.map
