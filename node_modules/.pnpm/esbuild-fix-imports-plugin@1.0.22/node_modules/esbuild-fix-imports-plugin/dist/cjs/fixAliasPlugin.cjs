"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var fixAliasPlugin_exports = {};
__export(fixAliasPlugin_exports, {
  fixAliasPlugin: () => fixAliasPlugin,
  getPathWithoutExtension: () => getPathWithoutExtension
});
module.exports = __toCommonJS(fixAliasPlugin_exports);
var import_path = require("path");
var import_load_tsconfig = require("load-tsconfig");
var import_fs = require("fs");
const originAbsolutePath = process.cwd();
const toPosix = (p) => p.replace(/\\/g, "/");
const normalizeImportPath = (p) => toPosix(p).replace(/\/\.\//g, "/").replace(/(^|[^:])\/\/+/g, "$1/");
const ensureDotRelative = (p) => {
  if (p.startsWith("./") || p.startsWith("../")) {
    return p;
  }
  if (p.startsWith("/")) {
    return `.${p}`;
  }
  return `./${p}`;
};
const fixAliasPlugin = () => ({
  name: "fixAliasPlugin",
  setup: (build) => {
    const outDir = build.initialOptions.outdir ?? "dist";
    const outDirAbsolutePath = (0, import_path.resolve)(originAbsolutePath, outDir);
    const outExtension = build.initialOptions.outExtension?.[".js"] ?? ".js";
    const tsConfig = (0, import_load_tsconfig.loadTsConfig)(
      originAbsolutePath,
      build.initialOptions.tsconfig ?? "./tsConfig.ts"
    );
    const alias = tsConfig?.data.compilerOptions?.paths ?? {};
    const baseUrl = tsConfig?.data.compilerOptions?.baseUrl;
    build.onEnd((result) => {
      if (result.errors.length > 0) {
        return;
      }
      const entryFiles = build.initialOptions.entryPoints ?? [];
      const outputFiles = (result.outputFiles ?? []).filter(
        (outputFile) => outputFile.path.endsWith(outExtension)
      );
      for (const outputFile of outputFiles) {
        const relativeOutputPath = (0, import_path.relative)(
          // '/Users/user/Documents/app/dist/esm/',
          outDirAbsolutePath,
          // '/Users/user/Documents/app/dist/esm/folder/index.mjs',
          outputFile.path
        );
        const relativeOutputPathWithoutExt = getPathWithoutExtension(relativeOutputPath);
        const entryFile = entryFiles.map(toPosix).find(
          (filePath) => filePath.includes(relativeOutputPathWithoutExt)
        ) ?? "";
        const entryFilePathWithoutExt = getPathWithoutExtension(entryFile);
        const ignoredPath = entryFilePathWithoutExt.replace(
          relativeOutputPathWithoutExt,
          ""
        );
        const relativePath = (0, import_path.relative)(
          // '/Users/user/Documents/app/dist/esm/folder',
          (0, import_path.dirname)(outputFile.path),
          // '/Users/user/Documents/app/dist/esm/',
          outDirAbsolutePath
        );
        const fileContents = outputFile.text;
        const nextFileContents = modifyAlias(
          fileContents,
          relativePath,
          alias,
          ignoredPath,
          baseUrl,
          originAbsolutePath
        );
        outputFile.contents = Buffer.from(nextFileContents);
      }
    });
  }
});
const getPathWithoutExtension = (path) => {
  const parsedPath = (0, import_path.parse)(path);
  return toPosix((0, import_path.join)(parsedPath.dir, parsedPath.name));
};
const ESM_IMPORT_EXP = /from\s*['"]([^'"]+)['"]/g;
const CJS_REQUIRE_EXP = /require\s*\(\s*['"]([^'"]+?)['"]\s*\)/g;
const modifyAlias = (contents, relativePath, alias, ignoredPath, baseUrl, originAbsolutePath2) => {
  let result = contents;
  result = result.replace(ESM_IMPORT_EXP, (match, importPath) => {
    const newImportPath = replaceAliasInPath(
      importPath,
      relativePath,
      alias,
      ignoredPath,
      baseUrl,
      originAbsolutePath2
    );
    return match.replace(importPath, newImportPath);
  });
  result = result.replace(CJS_REQUIRE_EXP, (match, importPath) => {
    const newImportPath = replaceAliasInPath(
      importPath,
      relativePath,
      alias,
      ignoredPath,
      baseUrl,
      originAbsolutePath2
    );
    return match.replace(importPath, newImportPath);
  });
  return result;
};
const cleanPath = (path) => normalizeImportPath(path);
const replaceAliasInPath = (importPath, relativePath, alias, ignoredPath, baseUrl, originAbsolutePath2) => {
  for (const aliasKey in alias) {
    const aliasPatterns = alias[aliasKey];
    for (const aliasPattern of aliasPatterns) {
      const fixedAliasPattern = aliasPattern.replace(ignoredPath, "");
      if (aliasKey.endsWith("*")) {
        const aliasKeyBase = aliasKey.slice(0, -1);
        const aliasPatternBase = fixedAliasPattern.slice(0, -1);
        if (importPath.startsWith(aliasKeyBase)) {
          const restOfPath = importPath.slice(aliasKeyBase.length);
          const newRelativePath = `./${toPosix(
            relativePath
          )}/${aliasPatternBase}${restOfPath}`;
          let cleanedNewRelativePath = ensureDotRelative(
            normalizeImportPath(newRelativePath)
          );
          return cleanedNewRelativePath;
        }
      } else if (importPath === aliasKey) {
        const newRelativePath = `./${toPosix(
          relativePath
        )}/${fixedAliasPattern}`;
        let cleanedNewRelativePath = ensureDotRelative(
          normalizeImportPath(newRelativePath)
        );
        return cleanedNewRelativePath;
      }
    }
  }
  if (baseUrl && !isRelativeImport(importPath) && !isNodeModuleImport(importPath)) {
    const resolvedBaseUrl = (0, import_path.resolve)(originAbsolutePath2, baseUrl);
    const possibleExtensions = ["", ".ts", ".tsx", ".js", ".jsx", ".json"];
    let foundPath = null;
    for (const ext of possibleExtensions) {
      const fullPath = (0, import_path.resolve)(resolvedBaseUrl, importPath + ext);
      if ((0, import_fs.existsSync)(fullPath)) {
        foundPath = fullPath;
        break;
      }
      const indexPath = (0, import_path.resolve)(resolvedBaseUrl, importPath, "index" + ext);
      if ((0, import_fs.existsSync)(indexPath)) {
        foundPath = indexPath;
        break;
      }
    }
    if (foundPath) {
      const relativeToBase = (0, import_path.relative)(resolvedBaseUrl, foundPath);
      const cleanedRelativeToBase = getPathWithoutExtension(relativeToBase);
      const newRelativePath = `./${toPosix(
        relativePath
      )}/${cleanedRelativeToBase}`;
      const cleanedNewRelativePath = ensureDotRelative(
        normalizeImportPath(newRelativePath)
      );
      return cleanedNewRelativePath;
    }
  }
  return importPath;
};
const isRelativeImport = (importPath) => {
  return importPath.startsWith("./") || importPath.startsWith("../");
};
const isNodeModuleImport = (importPath) => {
  if (importPath.startsWith(".") || importPath.startsWith("/")) {
    return false;
  }
  if (!importPath.includes("/")) {
    return true;
  }
  if (importPath.startsWith("@")) {
    return true;
  }
  return false;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  fixAliasPlugin,
  getPathWithoutExtension
});
//# sourceMappingURL=fixAliasPlugin.cjs.map