'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const fs = require('fs');
const zlib = require('zlib');
const common = require('@boost/common');
const optimal = require('@boost/common/optimal');
const constants = require('../constants.cjs');
const Transport = require('../Transport.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const fs__default = /*#__PURE__*/_interopDefault(fs);
const zlib__default = /*#__PURE__*/_interopDefault(zlib);
class FileTransport extends Transport.Transport {
  constructor(options) {
    super(options);
    this.path = void 0;
    this.stream = void 0;
    this.buffer = '';
    this.draining = false;
    this.lastSize = 0;
    this.rotating = false;
    this.path = common.Path.resolve(this.options.path);
    this.checkFolderRequirements();
  }
  blueprint(schemas) {
    const bool = schemas.bool,
      number = schemas.number;
    return _objectSpread(_objectSpread({}, super.blueprint(schemas)), {}, {
      gzip: bool(),
      maxSize: number(constants.MAX_LOG_SIZE).positive(),
      path: optimal.portablePathSchema.required()
    });
  }

  /**
   * Close the file stream and trigger the callback when finished.
   */
  close(commit) {
    const onClose = () => {
      commit?.();
      this.stream = undefined;
    };
    if (this.stream) {
      this.stream.once('finish', onClose).end();
    } else {
      onClose();
    }
  }

  /**
   * Open the file stream for writing.
   */
  open() {
    if (this.stream) {
      return this.stream;
    }
    this.stream = this.createStream();
    if (this.path.exists()) {
      this.lastSize = fs__default.default.statSync(this.path.path()).size;
    }
    if (this.buffer) {
      const message = this.buffer;
      this.buffer = '';
      this.write(message);
    }
    return this.stream;
  }

  /**
   * Write a message to the file stream, and rotate files once written if necessary.
   */
  write(message) {
    if (this.rotating) {
      this.buffer += message;
      return;
    }
    const stream = this.open();
    const written = stream.write(message, 'utf8', () => {
      this.lastSize += Buffer.byteLength(message);
      this.checkIfNeedsRotation();
    });

    // istanbul ignore next
    if (!written) {
      this.draining = true;
      stream.once('drain', () => {
        this.draining = false;
      });
    }
  }

  /**
   * Check that the parent folder exists and has the correct permissions.
   */
  checkFolderRequirements() {
    fs__default.default.mkdirSync(this.path.parent().path(), {
      recursive: true
    });
  }

  /**
   * Check if we should change and rotate files because of max size.
   */
  checkIfNeedsRotation() {
    // @ts-expect-error Valid is defined
    if (this.options && this.lastSize > this.options.maxSize) {
      this.closeStreamAndRotateFile();
    }
  }

  /**
   * Open and create a file stream for the defined path.
   * Apply file size and gzip checks.
   */
  createStream() {
    const stream = fs__default.default.createWriteStream(this.path.path(), {
      encoding: 'utf8',
      flags: 'a'
    });

    // Apply gzip compression to the stream
    if (this.options.gzip) {
      const gzip = zlib__default.default.createGzip();
      gzip.pipe(stream);
      return gzip;
    }
    return stream;
  }

  /**
   * Return the file name with extension, of the newly rotated file.
   */
  getRotatedFileName() {
    return this.path.name();
  }

  /**
   * Count the number of files within path directory that matches the given file name.
   */
  getNextIncrementCount(name) {
    const files = fs__default.default.readdirSync(this.path.parent().path());
    const pattern = new RegExp(`^${name}.\\d+$`, 'u');
    let count = 0;
    files.forEach(file => {
      if (file.match(pattern)) {
        count += 1;
      }
    });
    return count;
  }

  /**
   * Close the open stream and attempt to rotate the file.
   */
  closeStreamAndRotateFile() {
    // istanbul ignore next
    if (this.draining || this.rotating) {
      return;
    }
    this.rotating = true;
    this.close(() => {
      this.rotateFile();
      this.rotating = false;
    });
  }

  /**
   * Rotate the current file into a new file with an incremented name.
   */
  rotateFile() {
    let fileName = this.getRotatedFileName();
    if (this.options.gzip) {
      fileName += '.gz';
    }
    fileName += `.${this.getNextIncrementCount(fileName)}`;
    fs__default.default.renameSync(this.path.path(), this.path.parent().append(fileName).path());
    this.lastSize = 0;
  }
}
exports.FileTransport = FileTransport;
//# sourceMappingURL=FileTransport.cjs.map
