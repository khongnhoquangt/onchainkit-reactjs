'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const os = require('os');
const util = require('util');
const common = require('@boost/common');
const internal = require('@boost/internal');
const constants = require('./constants.cjs');
const debug = require('./debug.cjs');
const Transport = require('./Transport.cjs');
const ConsoleTransport = require('./transports/ConsoleTransport.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const os__default = /*#__PURE__*/_interopDefault(os);
const util__default = /*#__PURE__*/_interopDefault(util);
class Logger extends common.Contract {
  constructor(options) {
    super(options);
    this.silent = false;
    const defaultLevel = internal.env('LOG_DEFAULT_LEVEL');
    const maxLevel = internal.env('LOG_MAX_LEVEL');
    debug.debug('New logger "%s" created: %s %s', this.options.name, defaultLevel ? `${defaultLevel} level` : 'all levels', maxLevel ? `(max ${maxLevel})` : '');
  }
  blueprint(schemas) {
    const array = schemas.array,
      instance = schemas.instance,
      object = schemas.object,
      string = schemas.string;
    return {
      labels: object().of(string()),
      metadata: object(),
      name: string().required().notEmpty(),
      transports: array([new ConsoleTransport.ConsoleTransport()]).of(instance().of(Transport.Transport).notNullable())
    };
  }

  /**
   * Disable all logger messages from logging to the console.
   */
  disable() {
    debug.debug('Logger %s disabled', this.options.name);
    this.silent = true;
  }

  /**
   * Enable all logger messages to log the console.
   */
  enable() {
    debug.debug('Logger %s enabled', this.options.name);
    this.silent = false;
  }
  isAllowed(level, maxLevel) {
    if (!maxLevel) {
      return true;
    }
    for (const currentLevel of constants.LOG_LEVELS) {
      if (currentLevel === level) {
        return true;
      }
      if (currentLevel === maxLevel) {
        break;
      }
    }
    return false;
  }
  log(options) {
    const _options$args = options.args,
      args = _options$args === void 0 ? [] : _options$args,
      level = options.level,
      message = options.message,
      _options$metadata = options.metadata,
      metadata = _options$metadata === void 0 ? {} : _options$metadata;
    const logLevel = level ?? internal.env('LOG_DEFAULT_LEVEL') ?? 'log';
    if (this.silent || !this.isAllowed(logLevel, internal.env('LOG_MAX_LEVEL'))) {
      return;
    }
    const item = {
      host: os__default.default.hostname(),
      label: this.options.labels[logLevel] ?? constants.DEFAULT_LABELS[logLevel] ?? '',
      level: logLevel,
      message: util__default.default.format(message, ...args),
      metadata: _objectSpread(_objectSpread({}, this.options.metadata), metadata),
      name: this.options.name,
      pid: process.pid,
      time: new Date()
    };
    this.options.transports.forEach(transport => {
      if (transport.levels.includes(item.level)) {
        void transport.write(transport.format(item), item);
      }
    });
  }
}
exports.Logger = Logger;
//# sourceMappingURL=Logger.cjs.map
