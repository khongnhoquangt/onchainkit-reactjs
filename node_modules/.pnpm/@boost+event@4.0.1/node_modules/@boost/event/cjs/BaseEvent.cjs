'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const constants = require('./constants.cjs');
const debug = require('./debug.cjs');
const EventError = require('./EventError.cjs');
class BaseEvent {
  constructor(name) {
    this.listeners = new Map();
    this.name = void 0;
    this.name = this.validateName(name, 'name');
    if (process.env.NODE_ENV !== "production") {
      debug.debug('New %S created: %s', this.constructor.name, name);
    }
  }

  /**
   * Remove all listeners from the event.
   */
  clearListeners(scope) {
    if (scope) {
      this.getListeners(scope).clear();
    } else {
      this.listeners.clear();
    }
    return this;
  }

  /**
   * Return a set of listeners for a specific event scope.
   */
  getListeners(scope) {
    const key = this.validateName(scope ?? constants.WILDCARD_SCOPE, 'scope');
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    return this.listeners.get(key);
  }

  /**
   * Return a list of all scopes with listeners.
   */
  getScopes() {
    return [...this.listeners.keys()];
  }

  /**
   * Register a listener to the event.
   */
  listen(listener, scope) {
    if (process.env.NODE_ENV !== "production") {
      debug.debug('Registering "%s" listener', this.name);
    }
    this.getListeners(scope).add(this.validateListener(listener));
    return () => {
      this.unlisten(listener, scope);
    };
  }

  /**
   * Register a listener to the event that only triggers once.
   */
  once(listener, scope) {
    const func = this.validateListener(listener);
    const handler = (...args) => {
      this.unlisten(handler);
      return func(...args);
    };
    return this.listen(handler, scope);
  }

  /**
   * Remove a listener from the event.
   */
  unlisten(listener, scope) {
    if (process.env.NODE_ENV !== "production") {
      debug.debug('Unregistering "%s" listener', this.name);
    }
    this.getListeners(scope).delete(listener);
    return this;
  }

  /**
   * Validate the listener is a function.
   */
  validateListener(listener) {
    if (process.env.NODE_ENV !== "production" && typeof listener !== 'function') {
      throw new EventError.EventError('LISTENER_INVALID', [this.name]);
    }
    return listener;
  }

  /**
   * Validate the name/scope match a defined pattern.
   */
  validateName(name, type) {
    if (type === 'scope' && name === constants.WILDCARD_SCOPE) {
      return name;
    }
    if (process.env.NODE_ENV !== "production" && !name.match(constants.EVENT_NAME_PATTERN)) {
      throw new EventError.EventError('NAME_INVALID', [type, name]);
    }
    return name;
  }

  /**
   * Emit the event by executing all scoped listeners with the defined arguments.
   */
}

exports.BaseEvent = BaseEvent;
//# sourceMappingURL=BaseEvent.cjs.map
