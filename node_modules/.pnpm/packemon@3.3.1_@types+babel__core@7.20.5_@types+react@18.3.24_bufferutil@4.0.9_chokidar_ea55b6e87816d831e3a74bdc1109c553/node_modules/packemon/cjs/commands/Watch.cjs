'use strict';

const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.cjs');
const cli = require('@boost/cli');
const common = require('@boost/common');
const loadModule = require('../helpers/loadModule.cjs');
const Base = require('./Base.cjs');
var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2;
let WatchCommand = (_dec = cli.Config('watch', 'Watch local files for changes and rebuild'), _dec2 = cli.Arg.Number('Number of milliseconds to wait after a change before triggering a rebuild'), _dec3 = cli.Arg.Flag('Poll for file changes instead of using file system events'), _dec4 = common.Bind(), _dec(_class = (_class2 = class WatchCommand extends Base.BaseCommand {
  constructor(...args) {
    super(...args);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "debounce", _descriptor, this);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "poll", _descriptor2, this);
    this.package = null;
    this.rebuild = false;
    this.rebuilding = false;
    this.rebuildTimer = void 0;
  }
  enqueueRebuild(event, path) {
    if (event !== 'add' && event !== 'change' && event !== 'unlink') {
      return;
    }
    this.log(cli.applyStyle(' - %s', 'muted'), path.replace(`${this.packemon.workingDir.path()}/`, ''));
    this.triggerRebuild();
  }
  async run() {
    const packemon = this.packemon;
    const chokidar = loadModule.loadModule('chokidar', 'Chokidar is required for file watching.');
    packemon.debug('Starting `watch` process');

    // Generate all our build artifacts
    this.package = await this.getPackage();

    // Instantiate the watcher for each package source
    const watchPaths = this.package.path.append('src/**/*').path();
    packemon.debug('Initializing chokidar watcher for paths:');
    packemon.debug(watchPaths);
    const watcher = chokidar.watch(watchPaths, {
      ignored: /(^|[/\\])\../u,
      // dotfiles
      ignoreInitial: true,
      persistent: true,
      usePolling: this.poll
    });

    // Rebuild when files change
    watcher.on('all', this.enqueueRebuild);
    this.log('Watching for changes...');
  }
  triggerRebuild() {
    if (this.rebuildTimer) {
      clearTimeout(this.rebuildTimer);
    }
    this.rebuildTimer = setTimeout(() => {
      void this.rebuildPackage();
    }, this.debounce);
  }
  async rebuildPackage() {
    if (this.rebuilding) {
      this.triggerRebuild();
      return;
    }
    if (!this.package) {
      return;
    }
    this.rebuilding = true;
    try {
      const start = Date.now();
      await this.packemon.build(this.package, {
        loadConfigs: this.loadConfigs
      });
      this.log(cli.applyStyle('Built %s in %s', 'success'), this.package.getName(), common.formatMs(Date.now() - start));
    } catch (error) {
      if (error instanceof Error) {
        this.log.error(error.message);
      }
      this.log(cli.applyStyle('Failed to build %s', 'failure'), this.package.getName());
    } finally {
      this.rebuilding = false;
    }
  }
}, (_descriptor = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "debounce", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 150;
  }
}), _descriptor2 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "poll", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "enqueueRebuild", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "enqueueRebuild"), _class2.prototype)), _class2)) || _class);
exports.WatchCommand = WatchCommand;
//# sourceMappingURL=Watch.cjs.map
