'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.cjs');
const path = require('node:path');
const node_url = require('node:url');
const glob = require('fast-glob');
const fs = require('fs-extra');
const cli = require('@boost/cli');
const common = require('@boost/common');
const jsxRuntime = require('react/jsx-runtime');
var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const path__default = /*#__PURE__*/_interopDefault(path);
const glob__default = /*#__PURE__*/_interopDefault(glob);
const fs__default = /*#__PURE__*/_interopDefault(fs);
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
let ScaffoldCommand = (_dec = cli.Config('scaffold', 'Scaffold projects and packages with ease'), _dec2 = cli.Arg.Flag('Overwrite files if they already exist', {
  short: 'f'
}), _dec3 = cli.Arg.String('Package manager to install dependencies with', {
  choices: ['npm', 'pnpm', 'yarn']
}), _dec4 = cli.Arg.String('Folder in which packages will be located (monorepo only)'), _dec5 = cli.Arg.Flag('Skip installation of npm dependencies'), _dec6 = cli.Arg.String('Default template to scaffold', {
  choices: ['monorepo', 'monorepo-package', 'polyrepo', 'polyrepo-package']
}), _dec7 = cli.Arg.Params({
  label: 'destination',
  description: 'Destination to copy template to',
  type: 'string',
  required: true
}), _dec(_class = (_class2 = class ScaffoldCommand extends cli.Command {
  constructor(...args) {
    super(...args);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "force", _descriptor, this);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "packageManager", _descriptor2, this);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "packagesFolder", _descriptor3, this);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "skipInstall", _descriptor4, this);
    _rollupPluginBabelHelpers.initializerDefineProperty(this, "template", _descriptor5, this);
    this.dest = '';
    this.destDir = '';
  }
  async run(dest) {
    this.dest = dest;
    this.destDir = path__default.default.join(process.cwd(), dest);

    // This is purely for testing in CI, as we have no way to pass stdin
    if (process.env.CI) {
      await this.scaffold({
        author: 'Packemon',
        template: this.template,
        projectName: 'packemon',
        packageName: 'example',
        packagePath: 'packages/example',
        repoUrl: 'packemon',
        year: new Date().getFullYear()
      });
      return undefined;
    }

    // eslint-disable-next-line import/no-useless-path-segments
    const _await$import = await import('../components/Scaffold/index.cjs'),
      Scaffold = _await$import.Scaffold;
    return /*#__PURE__*/jsxRuntime.jsx(Scaffold, {
      defaultTemplate: this.template,
      onComplete: params => this.scaffold(params)
    });
  }
  async scaffold(params) {
    switch (params.template) {
      case 'polyrepo-package':
        return this.scaffoldPolyrepoPackage(params);
      case 'polyrepo':
        return this.scaffoldPolyrepo(params);
      case 'monorepo-package':
        return this.scaffoldMonorepoPackage(params);
      default:
        return this.scaffoldMonorepo(params);
    }
  }
  async scaffoldMonorepo(params) {
    await this.checkExistingInfrastructure('monorepo');
    await this.copyFilesFromTemplate('base', this.destDir, params);
    await this.copyFilesFromTemplate('monorepo', this.destDir, _objectSpread(_objectSpread({}, params), {}, {
      packagesFolder: this.packagesFolder
    }));
    await this.installDependencies('monorepo');
    try {
      await fs__default.default.mkdir(path__default.default.join(this.destDir, this.packagesFolder));
    } catch {
      // Ignore
    }
  }
  async scaffoldMonorepoPackage(params) {
    const packagesDir = path__default.default.join(this.destDir, this.packagesFolder);
    fs__default.default.mkdirSync(packagesDir, {
      recursive: true
    });
    const packageName = params.packageName;
    const folderName = packageName.startsWith('@') ? packageName.split('/')[1] : packageName;
    const packageDir = path__default.default.join(packagesDir, folderName);
    const packagePath = `${this.packagesFolder}/${folderName}`;
    await this.copyFilesFromTemplate('package', packageDir, params);
    await this.copyFilesFromTemplate('monorepo-package', packageDir, _objectSpread(_objectSpread({}, params), {}, {
      packagePath
    }));
    await this.addProjectReference(packagePath);
  }
  async scaffoldPolyrepo(params) {
    await this.checkExistingInfrastructure('polyrepo');
    await this.copyFilesFromTemplate('base', this.destDir, params);
    await this.copyFilesFromTemplate('polyrepo', this.destDir, params);
    await this.installDependencies('polyrepo');
  }
  async scaffoldPolyrepoPackage(params) {
    // Since a polyrepo and package are the same thing, scaffold the infra automatically
    await this.scaffoldPolyrepo(params);
    await this.copyFilesFromTemplate('package', this.destDir, params);
  }
  async addProjectReference(packagePath) {
    const tsconfigPath = path__default.default.join(this.destDir, 'tsconfig.json');
    const tsconfig = await this.loadJsonConfig(tsconfigPath);
    if (!Array.isArray(tsconfig.references)) {
      tsconfig.references = [];
    }
    tsconfig.references.push({
      path: packagePath
    });
    tsconfig.references.sort((a, b) => a.path.localeCompare(b.path));
    await fs__default.default.writeJson(tsconfigPath, tsconfig, {
      spaces: 2
    });
  }
  async installDependencies(type) {
    if (this.skipInstall) {
      return;
    }
    const args = ['@types/jest', '@types/node', 'eslint-config-moon', 'eslint', 'jest-preset-moon', 'jest', 'packemon', 'prettier-config-moon', 'prettier', 'tsconfig-moon', 'typescript'];
    switch (this.packageManager) {
      case 'npm':
        args.unshift('install', '--save-dev');
        break;
      case 'pnpm':
        args.unshift('add', '--save-dev', type === 'monorepo' ? '-W' : '');
        break;
      default:
        {
          const version = Number.parseFloat((await this.executeCommand('yarn', ['-v'], {
            preferLocal: false
          })).stdout);
          args.unshift('add', '--dev', type === 'monorepo' && version < 2 ? '-W' : '');
          break;
        }
    }
    await this.executeCommand(this.packageManager, args.filter(Boolean), {
      cwd: this.destDir
    });
  }
  async checkExistingInfrastructure(type) {
    const packagePath = path__default.default.join(this.destDir, 'package.json');
    if (!fs__default.default.existsSync(packagePath)) {
      return;
    }
    const pkg = await this.loadJsonConfig(packagePath);
    if (pkg.infra === undefined) {
      throw new Error(`A package.json already exists, cannot setup ${type}. Perhaps you want "${type}-package"?`);
    } else if (pkg.infra !== type) {
      throw new Error(`Cannot scaffold ${type}, as destination has already been setup as a ${pkg.infra}.`);
    }
  }
  async copyFile(fromTemplate, toDest, params) {
    const isPackage = fromTemplate.endsWith('package.json') && toDest.endsWith('package.json');

    // Dont overwrite existing files (except package.json)
    if (fs__default.default.existsSync(toDest) && !this.force && !isPackage) {
      return;
    }
    const toDir = path__default.default.dirname(toDest);
    if (!fs__default.default.existsSync(toDir)) {
      await fs__default.default.ensureDir(toDir);
    }

    // Interpolate params into string content
    let content = await fs__default.default.readFile(fromTemplate, 'utf8');
    Object.entries(params).forEach(([key, value]) => {
      content = content.replace(new RegExp(`<${key}>`, 'g'), String(value));
    });

    // Instead of overwriting package.json, we want to merge them
    if (fs__default.default.existsSync(toDest) && isPackage) {
      const prevContent = await this.loadJsonConfig(toDest);
      const nextContent = common.json.parse(content);
      await fs__default.default.writeJson(toDest, _objectSpread(_objectSpread({}, prevContent), nextContent), {
        spaces: 2
      });

      // Otherwise write content as a string
    } else {
      await fs__default.default.writeFile(toDest, content, 'utf8');
    }
  }
  async copyFilesFromTemplate(template, destDir, params) {
    const templateDir = node_url.fileURLToPath(new URL(`../../templates/${template}`, typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL('commands/Scaffold.cjs', document.baseURI).href));
    const files = await glob__default.default('**/*', {
      absolute: false,
      dot: true,
      cwd: templateDir
    });
    return Promise.all(files.map(file => this.copyFile(path__default.default.join(templateDir, file), path__default.default.join(destDir, file), _objectSpread({}, params))));
  }
  async loadJsonConfig(filePath) {
    // Supports comments
    return common.json.parse(await fs__default.default.readFile(filePath, 'utf8'));
  }
}, (_descriptor = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "force", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor2 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "packageManager", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'yarn';
  }
}), _descriptor3 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "packagesFolder", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 'packages';
  }
}), _descriptor4 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "skipInstall", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return false;
  }
}), _descriptor5 = _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "template", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class2.prototype, "run", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "run"), _class2.prototype)), _class2)) || _class);
exports.ScaffoldCommand = ScaffoldCommand;
//# sourceMappingURL=Scaffold.cjs.map
