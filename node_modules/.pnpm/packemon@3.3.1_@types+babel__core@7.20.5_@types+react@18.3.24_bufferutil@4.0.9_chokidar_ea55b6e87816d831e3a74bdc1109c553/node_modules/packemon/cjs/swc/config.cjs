'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const constants = require('../constants.cjs');
const shouldKeepDynamicImport = require('../helpers/shouldKeepDynamicImport.cjs');
function getModuleConfigType(format) {
  switch (format) {
    case 'esm':
    case 'mjs':
      return 'es6';
    case 'umd':
      return 'umd';
    default:
      return 'commonjs';
  }
}
function getPlatformEnvOptions(platform, support, format) {
  switch (platform) {
    case 'browser':
      return {
        targets: Array.isArray(constants.BROWSER_TARGETS[support]) ? constants.BROWSER_TARGETS[support].join(', ') : constants.BROWSER_TARGETS[support]
      };
    case 'electron':
      return {
        targets: {
          electron: constants.ELECTRON_TARGETS[support]
        }
      };
    case 'native':
      return {
        targets: constants.NATIVE_TARGETS[support]
      };
    case 'node':
      return {
        targets: {
          node: constants.NODE_SUPPORTED_VERSIONS[support]
        }
      };
    default:
      throw new Error(`Unknown platform "${platform}".`);
  }
}
function getSharedConfig(config) {
  return _objectSpread(_objectSpread({}, config), {}, {
    jsc: _objectSpread(_objectSpread({}, config.jsc), {}, {
      keepClassNames: true,
      preserveAllComments: true
    }),
    caller: {
      name: 'packemon'
    },
    // Do NOT load `.swcrc` files as we need full control
    configFile: false,
    swcrc: false
  });
}

// The input config should only parse special syntax, not transform and downlevel.
// This applies to all formats within a build target.
function getSwcInputConfig(artifact, features, packemonConfig = {}) {
  const transform = {
    // Keep the input as similar as possible
    optimizer: undefined
  };
  const baseConfig = {
    module: {
      type: 'es6',
      ignoreDynamic: true
    },
    jsc: {
      parser: {
        syntax: 'ecmascript',
        jsx: !!features.react || !!features.solid,
        dynamicImport: true
      },
      transform,
      externalHelpers: artifact.features.helpers === 'external' || artifact.features.helpers === 'runtime',
      loose: false,
      target: constants.SUPPORT_TO_ESM_SPEC.experimental
    }
  };
  if (features.typescript) {
    const parser = {
      syntax: 'typescript',
      tsx: !!features.react || !!features.solid,
      dynamicImport: true
    };
    if (features.decorators) {
      parser.decorators = true;
      transform.legacyDecorator = true;
    }
    baseConfig.jsc.parser = parser;
  }
  if (features.react) {
    transform.react = {
      runtime: features.react,
      throwIfNamespace: true
    };
  }

  // TODO: this doesn't work right, skip for now
  // if (features.solid) {
  // 	transform.react = {
  // 		runtime: 'classic',
  // 		importSource: 'solid-js/web',
  // 		pragma: 'createComponent',
  // 		pragmaFrag: 'Fragment',
  // 		throwIfNamespace: true,
  // 	};
  // }

  const config = getSharedConfig(baseConfig);

  // Allow consumers to mutate
  packemonConfig.swcInput?.(config);
  return config;
}

// The output config does all the transformation and downleveling through the preset-env.
// This is handled per output since we need to configure based on target + format combinations.
function getSwcOutputConfig(platform, support, format, features, packemonConfig = {}) {
  const env = _objectSpread({
    // Prefer spec compliance in development
    loose: false,
    // Consumers must polyfill accordingly
    mode: undefined,
    // useBuiltIns
    // Transform features accordingly
    // @ts-expect-error Not typed
    bugfixes: true,
    shippedProposals: true
  }, getPlatformEnvOptions(platform, support, format));
  const module = {
    type: getModuleConfigType(format),
    ignoreDynamic: shouldKeepDynamicImport.shouldKeepDynamicImport(platform, support)
  };

  // This is to trick the Babel plugin to not transform the const
  const id = name => `__${name}__`;

  // Now we can downlevel
  const baseConfig = {
    env,
    module,
    jsc: {
      parser: {
        syntax: 'ecmascript'
      },
      transform: {
        optimizer: {
          globals: {
            vars: {
              [id('DEV')]: "process.env.NODE_ENV !== 'production'",
              [id('PROD')]: "process.env.NODE_ENV === 'production'",
              [id('TEST')]: "process.env.NODE_ENV === 'test'"
            }
          }
        }
      }
      // target: SUPPORT_TO_ESM_SPEC[support],
    }
  };
  const config = getSharedConfig(baseConfig);

  // Allow consumers to mutate
  packemonConfig.swcOutput?.(config, {
    features,
    format,
    platform,
    support
  });
  return config;
}
exports.getSwcInputConfig = getSwcInputConfig;
exports.getSwcOutputConfig = getSwcOutputConfig;
//# sourceMappingURL=config.cjs.map
