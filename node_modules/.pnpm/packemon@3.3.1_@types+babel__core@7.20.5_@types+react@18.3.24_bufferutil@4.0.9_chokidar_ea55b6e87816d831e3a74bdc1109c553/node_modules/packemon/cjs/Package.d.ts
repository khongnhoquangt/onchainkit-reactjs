import { Path } from '@boost/common';
import { Debugger } from '@boost/debug';
import { Artifact } from './Artifact';
import { ApiType, BuildOptions, ConfigFile, FeatureFlags, PackageConfig, PackemonPackage, PackemonPackageConfig } from './types';
export declare class Package {
    readonly artifacts: Artifact[];
    readonly configs: PackageConfig[];
    readonly debug: Debugger;
    readonly json: PackemonPackage;
    readonly jsonPath: Path;
    readonly path: Path;
    readonly workspaceRoot: Path;
    constructor(path: Path, contents: Partial<PackemonPackage>, workspaceRoot?: Path);
    build(options: BuildOptions, packemonConfig: ConfigFile): Promise<void>;
    clean(): Promise<void>;
    findDistributableFiles(): Promise<string[]>;
    findSourceFiles(): Promise<string[]>;
    /**
     * Generate artifacts based on the packemon configuration.
     */
    generateArtifacts({ declaration, filterFormats, filterPlatforms }?: BuildOptions): void;
    getFeatureFlags(): FeatureFlags;
    getName(): string;
    getSlug(): string;
    hasDependency(name: string): boolean;
    setConfigs(configs: PackemonPackageConfig[]): void;
    syncJson(): Promise<void>;
    protected addEngines(): void;
    protected addEntryPoints(): void;
    protected addExports(features: FeatureFlags): void;
    protected addFiles(): void;
    /**
     * When 1 config needs a private API, all other configs should be private,
     * otherwise we will have conflicting output structures and exports.
     */
    protected determineApiType(): ApiType;
    /**
     * Format "lib" is a shared format across all platforms,
     * and when a package wants to support multiple platforms,
     * we must account for this and alter the output paths.
     */
    protected requiresSharedLib(): boolean;
}
//# sourceMappingURL=Package.d.ts.map