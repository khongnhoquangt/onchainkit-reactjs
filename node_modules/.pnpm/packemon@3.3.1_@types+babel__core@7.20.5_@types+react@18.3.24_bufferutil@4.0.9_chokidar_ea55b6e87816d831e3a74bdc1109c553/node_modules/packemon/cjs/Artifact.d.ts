import { Debugger } from '@boost/debug';
import type { Package } from './Package';
import type { ApiType, ArtifactState, Build, BuildOptions, BuildResult, ConfigFile, FeatureFlags, Format, InputMap, PackageExports, PackemonPackageFeatures, Platform, Support } from './types';
export declare class Artifact {
    api: ApiType;
    bundle: boolean;
    builds: Build[];
    buildResult: BuildResult;
    configGroup: number;
    externals: string[];
    features: PackemonPackageFeatures;
    inputs: InputMap;
    namespace: string;
    platform: Platform;
    package: Package;
    sharedLib: boolean;
    support: Support;
    state: ArtifactState;
    protected debug: Debugger;
    constructor(pkg: Package, builds: Build[]);
    /**
     * Build code and types in parallel.
     */
    build(options: BuildOptions, features: FeatureFlags, packemonConfig: ConfigFile): Promise<void>;
    /**
     * Build code artifacts using Rollup. We'll spin up a Rollup instance for each output,
     * as Rollup will then generate all the necessary formats. For example:
     * index -> cjs, lib.
     */
    buildCode(features: FeatureFlags, packemonConfig: ConfigFile): Promise<void>;
    /**
     * Build type artifacts using TypeScript. We'll need to spin up an individual process
     * for each format, as they may require different declaration outputs or compiler options.
     */
    buildTypes(features: FeatureFlags): Promise<void>;
    clean(): Promise<void>;
    findEntryPoint(formats: Format[], outputName: string): {
        declExt: string | undefined;
        declPath: string | undefined;
        entryExt: string;
        entryPath: string;
        folder: string;
    } | undefined;
    getBuildOutput(format: Format, outputName: string, declaration?: boolean): {
        declExt: string | undefined;
        declPath: string | undefined;
        entryExt: string;
        entryPath: string;
        folder: string;
    };
    getIndexInput(): string;
    getInputPaths(): InputMap;
    getLabel(): string;
    getPackageExports(features: FeatureFlags): PackageExports;
    isComplete(): boolean;
    isRunning(): boolean;
    toString(): string;
    protected mapPackageExportsFromBuilds(outputName: string, exportMap: PackageExports, features: FeatureFlags, index?: boolean): void;
    protected logWithSource(message: string, level: 'error' | 'info' | 'warn', { id, output, sourceColumn, sourceFile, sourceLine, }?: {
        id?: string;
        output?: string;
        sourceColumn?: number;
        sourceFile?: string;
        sourceLine?: number;
    }): void;
}
//# sourceMappingURL=Artifact.d.ts.map