'use strict';

const node_module = require('node:module');
const path = require('node:path');
const node_url = require('node:url');
const doResolve = require('resolve');
var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const path__default = /*#__PURE__*/_interopDefault(path);
const doResolve__default = /*#__PURE__*/_interopDefault(doResolve);

// This is in a separate file so that we can mock in tests

// Babel resolves plugins against the current working directory
// and will not find globally installed dependencies unless we resolve.
// istanbul ignore next
function resolve(id) {
  let file = typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL('babel/resolve.cjs', document.baseURI).href;

  // Because of our Babel plugin and Rollup, this may get transpiled differently
  // @ts-expect-error Allow this instance check
  if (file instanceof URL || typeof file === 'string' && file.startsWith('file:')) {
    file = node_url.fileURLToPath(file);
  }
  return doResolve__default.default.sync(id, {
    basedir: path__default.default.dirname(file)
  });
}

// Furthermore, some plugins are dependents of Babel and not Packemon,
// so we need to resolve from that context for PnP to work correctly.
const babelRequire = node_module.createRequire(resolve('@babel/preset-env/package.json'));
function resolveFromBabel(id) {
  return babelRequire.resolve(id);
}
exports.resolve = resolve;
exports.resolveFromBabel = resolveFromBabel;
//# sourceMappingURL=resolve.cjs.map
