'use strict';

const node_crypto = require('node:crypto');
const path = require('node:path');
const fs = require('fs-extra');
const MagicString = require('magic-string');
const common = require('@boost/common');
const constants = require('../../constants.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const path__default = /*#__PURE__*/_interopDefault(path);
const fs__default = /*#__PURE__*/_interopDefault(fs);
const MagicString__default = /*#__PURE__*/_interopDefault(MagicString);
function isAsset(id) {
  return constants.ASSETS.some(ext => id.endsWith(ext));
}
function isRequireStatement(node) {
  return node && node.type === 'CallExpression' && node.callee && node.callee.type === 'Identifier' && node.callee.name === 'require' && node.arguments.length > 0 && node.arguments[0] && node.arguments[0].type === 'Literal';
}
function copyAndRefAssets({
  dir
}, assetsToCopyInit = {}) {
  const assetsToCopy = assetsToCopyInit;
  function determineNewAsset(source, importer) {
    let preparedImporter = importer ? path__default.default.dirname(importer) : '';

    // Find overlapping directory names and remove them
    const normalizedRelativePath = path__default.default.normalize(source);
    const absoluteParts = preparedImporter.split(path__default.default.sep);
    const relativeParts = normalizedRelativePath.split(path__default.default.sep);
    for (let i = absoluteParts.length - 1; i >= 0; i -= 1) {
      if (absoluteParts[i] === relativeParts[0] && absoluteParts.slice(i).every((p, idx) => p === relativeParts[idx])) {
        const overlap = absoluteParts.slice(i, absoluteParts.length).join(path__default.default.sep);
        preparedImporter = preparedImporter.slice(0, -overlap.length);
      }
    }
    const fullPath = path__default.default.join(preparedImporter, source);
    const id = new common.VirtualPath(fullPath);
    const ext = id.ext();
    const name = id.name(true);

    // Generate a hash of the source file path,
    // and have it match between nix and windows
    const hash = node_crypto.createHash('sha256').update(id.path().replace(new common.VirtualPath(path__default.default.dirname(dir)).path(), '')).digest('hex').slice(0, 8);

    // Create a new path that points to the assets folder
    const newId = new common.VirtualPath(dir, `${name}-${hash}${ext}`);
    assetsToCopy[id.path()] = newId;
    return newId;
  }
  return {
    name: 'packemon-copy-and-ref-assets',
    // Delete old assets to remove any possible stale assets
    async buildStart() {
      await fs__default.default.remove(dir);
    },
    // Find assets and mark as external
    resolveId(source, importer) {
      if (isAsset(source) && importer) {
        const id = path__default.default.join(path__default.default.dirname(importer), source);

        // Check that the file actually exists, because they may be
        // using path aliases, or bundler specific syntax
        if (source.startsWith('.') && fs__default.default.existsSync(id)) {
          return {
            id,
            external: true
          };
        }

        // Ignore files coming from node modules
        return false;
      }
      return null;
    },
    // Update import/require declarations to new asset paths
    renderChunk(code, chunk, options) {
      let ast;
      try {
        ast = this.parse(code);
      } catch {
        // Unknown syntax may fail parsing, not much we can do here?
        return null;
      }

      /*
      	chunk.facadeModuleId is not ideal because the bundled code gets moved up to the
      	root (output) directory compared to where it was located in the source files,
      	the imports in the source files that get bundled get changed to be relative
      	to the new bundle location, but the chunk.facadeModuleId is the old location of
      	the index. So, you have the old path + the new updated imports and there could be
      	overlap due to this "hoisting", which has a workaround in determineNewAsset
      */
      const parentId = chunk.facadeModuleId; // This correct?
      const magicString = new MagicString__default.default(code);
      let hasChanged = false;

      // eslint-disable-next-line complexity
      ast.body.forEach(node => {
        let source;

        // import './styles.css';
        if (node.type === 'ImportDeclaration') {
          // require('./styles.css');
          source = node.source;
        } else if (node.type === 'ExpressionStatement' && isRequireStatement(node.expression)) {
          source = node.expression.arguments[0];

          // const foo = require('./styles.css');
        } else if (node.type === 'VariableDeclaration' && node.declarations.length > 0 && node.declarations[0].init && isRequireStatement(node.declarations[0].init)) {
          source = node.declarations[0].init.arguments[0];
        }
        if (!source?.value) {
          return;
        }

        // Update to new path (ignore files coming from node modules)
        const sourcePath = String(source.value);
        if (sourcePath.includes(':')) {
          return;
        }
        const parentDir = parentId ? path__default.default.dirname(parentId) : '';
        if (sourcePath && isAsset(sourcePath) && sourcePath.startsWith('.') && fs__default.default.existsSync(path__default.default.join(parentDir, sourcePath))) {
          const newId = determineNewAsset(sourcePath, parentId);
          const importPath = options.preserveModules ? new common.VirtualPath(path__default.default.relative(parentDir, newId.path())).path() : `../assets/${newId.name()}`;

          // @ts-expect-error Not typed
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          magicString.overwrite(source.start, source.end, `'${importPath}'`);
          hasChanged = true;
        }
      });
      if (!hasChanged) {
        return null;
      }
      return {
        code: magicString.toString(),
        map: null
      };
    },
    // Copy all found assets
    async generateBundle() {
      // Only create the folder if we have assets to copy,
      // otherwise it throws off `files` and other detection!
      if (Object.keys(assetsToCopy).length > 0) {
        await fs__default.default.mkdir(dir, {
          recursive: true
        });
      }

      // We don't use `assetFileNames` as we want a single assets folder
      // at the root of the package, which Rollup does not allow. It wants
      // multiple asset folders within each format!
      await Promise.all(Object.entries(assetsToCopy).map(async ([oldId, newId]) => {
        if (!newId.exists()) {
          await fs__default.default.copyFile(oldId, newId.path());
        }
      }));
    }
  };
}
exports.copyAndRefAssets = copyAndRefAssets;
//# sourceMappingURL=copyAndRefAssets.cjs.map
