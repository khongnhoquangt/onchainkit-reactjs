'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const rollupPluginNodeExternals = require('rollup-plugin-node-externals');
const nodePolyfills = require('rollup-plugin-polyfill-node');
const pluginBabel = require('@rollup/plugin-babel');
const commonjs = require('@rollup/plugin-commonjs');
const json = require('@rollup/plugin-json');
const resolve = require('@rollup/plugin-node-resolve');
const config$1 = require('../babel/config.cjs');
const constants = require('../constants.cjs');
const config = require('../swc/config.cjs');
const addBinShebang = require('./plugins/addBinShebang.cjs');
const addMjsWrapperForCjs = require('./plugins/addMjsWrapperForCjs.cjs');
const copyAndRefAssets = require('./plugins/copyAndRefAssets.cjs');
const preserveDynamicImport = require('./plugins/preserveDynamicImport.cjs');
const swc = require('./plugins/swc.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const nodePolyfills__default = /*#__PURE__*/_interopDefault(nodePolyfills);
const commonjs__default = /*#__PURE__*/_interopDefault(commonjs);
const json__default = /*#__PURE__*/_interopDefault(json);
const resolve__default = /*#__PURE__*/_interopDefault(resolve);
function getRollupModuleFormat(format) {
  if (format === 'esm' || format === 'mjs' ||
  // UMD needs to be compiled with Babel instead of Rollup,
  // so we use ESM for better interoperability.
  format === 'umd') {
    return 'esm';
  }
  return 'cjs';
}
function getSiblingArtifacts(artifact) {
  return artifact.package.artifacts.filter(art => art.configGroup !== artifact.configGroup);
}
function getRollupPaths(artifact, ext) {
  const paths = {};
  if (artifact.bundle) {
    getSiblingArtifacts(artifact).forEach(art => {
      Object.entries(art.getInputPaths()).forEach(([outputName, inputPath]) => {
        // All output files are in the same directory, so we can hard-code a relative path
        paths[inputPath] = `./${outputName}.${ext}`;
      });
    });
  }
  return paths;
}
function getRollupExternals(artifact) {
  const foreignInputs = new Set();
  if (artifact.bundle) {
    const sameInputPaths = new Set(Object.values(artifact.getInputPaths()));
    getSiblingArtifacts(artifact).forEach(art => {
      Object.values(art.getInputPaths()).forEach(inputPath => {
        if (!sameInputPaths.has(inputPath)) {
          foreignInputs.add(inputPath);
        }
      });
    });
  }
  return (id, parent = '<unknown>') => {
    if (id.includes('@babel/') || id.includes('@swc/helpers')) {
      return true;
    }
    if (foreignInputs.has(id)) {
      throw new Error(`Unexpected foreign input import. May only import sibling files within the same \`inputs\` configuration group. File "${parent}" attempted to import "${id}".`);
    }
    for (const pattern of artifact.externals) {
      if (id.match(pattern)) {
        return true;
      }
    }
    return false;
  };
}

// eslint-disable-next-line complexity
function getRollupOutputConfig(artifact, features, format, packemonConfig = {}) {
  const platform = artifact.platform,
    support = artifact.support;
  const _artifact$getBuildOut = artifact.getBuildOutput(format, 'index'),
    entryExt = _artifact$getBuildOut.entryExt,
    folder = _artifact$getBuildOut.folder;
  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
  const isSwc = packemonConfig.swc || artifact.features.swc || !!process.env.PACKEMON_SWC;
  const isEsm = format === 'esm' || format === 'mjs';
  const output = {
    dir: artifact.package.path.append(folder).path(),
    format: getRollupModuleFormat(format),
    originalFormat: format,
    interop: 'auto',
    // Map our externals to local paths with trailing extension
    paths: getRollupPaths(artifact, entryExt),
    // Use our extension for file names
    assetFileNames: 'assets/[name].[ext]',
    chunkFileNames: `${artifact.bundle ? 'bundle' : '[name]'}-[hash].${entryExt}`,
    entryFileNames: `[name].${entryExt}`,
    preserveModules: !artifact.bundle,
    // Use ESM features when not supporting old targets
    generatedCode: {
      preset: 'es2015',
      arrowFunctions: true,
      constBindings: true,
      objectShorthand: true,
      symbols: isEsm
    },
    // Output specific plugins
    plugins: [preserveDynamicImport.preserveDynamicImport(platform, support), isSwc ? swc.swcOutput(_objectSpread(_objectSpread({}, config.getSwcOutputConfig(platform, support, format, features, packemonConfig)), {}, {
      filename: artifact.package.path.path(),
      // Maps were extracted before transformation
      sourceMaps: false
    })) : pluginBabel.getBabelOutputPlugin(_objectSpread(_objectSpread({}, config$1.getBabelOutputConfig(platform, support, format, features, packemonConfig, artifact.features.helpers)), {}, {
      filename: artifact.package.path.path(),
      // Provide a custom name for the UMD global
      moduleId: format === 'umd' ? artifact.namespace : undefined,
      // Maps were extracted before transformation
      sourceMaps: false
    })), addBinShebang.addBinShebang()],
    // Always include source maps
    sourcemap: true,
    sourcemapExcludeSources: true
  };

  // Disable warnings about default exports
  if (format === 'lib' || format === 'cjs') {
    output.exports = 'auto';
  }

  // Automatically prepend a shebang for binaries
  if (artifact.bundle && !(isSwc && format === 'umd')) {
    output.banner = ['// Bundled with Packemon: https://packemon.dev\n', `// Platform: ${platform}, Support: ${support}, Format: ${format}\n\n`].join('');
  }

  // Allow consumers to mutate
  packemonConfig.rollupOutput?.(output, {
    features,
    format,
    platform,
    support
  });
  return output;
}
async function getRollupConfig(artifact, features, packemonConfig = {}) {
  const packagePath = artifact.package.jsonPath.path();
  const isNode = artifact.platform === 'node';
  const isTest = process.env.NODE_ENV === 'test';
  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
  const isSwc = packemonConfig.swc || artifact.features.swc || !!process.env.PACKEMON_SWC;
  const config$2 = {
    external: getRollupExternals(artifact),
    input: artifact.bundle ? artifact.getInputPaths() : await artifact.package.findSourceFiles(),
    output: [],
    // Shared output plugins
    plugins: [
    // Mark all dependencies in `package.json` as external
    rollupPluginNodeExternals.externals({
      builtins: isNode,
      builtinsPrefix: isNode && artifact.support !== 'legacy' ? 'add' : 'strip',
      deps: true,
      devDeps: true,
      optDeps: true,
      packagePath,
      peerDeps: true
    }),
    // Externals MUST be listed before shared plugins
    resolve__default.default({
      extensions: constants.EXTENSIONS,
      preferBuiltins: true
    }), commonjs__default.default(), json__default.default({
      compact: true,
      namedExports: false
    }),
    // Copy assets and update import references
    copyAndRefAssets.copyAndRefAssets({
      dir: artifact.package.path.append('assets').path()
    }),
    // Declare Babel/swc here so we can parse TypeScript/Flow
    isSwc ? swc.swcInput(_objectSpread(_objectSpread({}, config.getSwcInputConfig(artifact, features, packemonConfig)), {}, {
      exclude: isTest ? [] : constants.EXCLUDE_RUST,
      filename: artifact.package.path.path(),
      // Extract maps from the original source
      sourceMaps: !isNode
    })) : pluginBabel.getBabelInputPlugin(_objectSpread(_objectSpread({}, config$1.getBabelInputConfig(artifact, features, packemonConfig)), {}, {
      babelHelpers: artifact.features.helpers,
      exclude: isTest ? [] : constants.EXCLUDE,
      extensions: constants.EXTENSIONS,
      filename: artifact.package.path.path(),
      skipPreflightCheck: true,
      // Extract maps from the original source
      sourceMaps: !isNode
    }))],
    // Treeshake for smaller builds
    treeshake: artifact.bundle
  };

  // Polyfill node modules when platform is not node
  if (!isNode) {
    config$2.plugins.unshift(nodePolyfills__default.default());
  }

  // Add an output for each format
  config$2.output = artifact.builds.map(build => {
    if (build.format === 'cjs') {
      config$2.plugins.push(addMjsWrapperForCjs.addMjsWrapperForCjs({
        inputs: artifact.inputs,
        packageRoot: artifact.package.path
      }));
    }
    return getRollupOutputConfig(artifact, features, build.format, packemonConfig);
  });

  // Allow consumers to mutate
  packemonConfig.rollupInput?.(config$2);
  return config$2;
}
exports.getRollupConfig = getRollupConfig;
exports.getRollupExternals = getRollupExternals;
exports.getRollupOutputConfig = getRollupOutputConfig;
//# sourceMappingURL=config.cjs.map
