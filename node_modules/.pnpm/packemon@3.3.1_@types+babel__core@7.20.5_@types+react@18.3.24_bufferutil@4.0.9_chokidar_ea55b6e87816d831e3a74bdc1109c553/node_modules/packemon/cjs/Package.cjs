'use strict';

const _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.cjs');
const glob = require('fast-glob');
const fs = require('fs-extra');
const semver = require('semver');
const common = require('@boost/common');
const optimal = require('@boost/common/optimal');
const debug = require('@boost/debug');
const Artifact = require('./Artifact.cjs');
const constants = require('./constants.cjs');
const loadTsconfigJson = require('./helpers/loadTsconfigJson.cjs');
const matchesPattern = require('./helpers/matchesPattern.cjs');
const mergeExports = require('./helpers/mergeExports.cjs');
const sortExports = require('./helpers/sortExports.cjs');
const schemas = require('./schemas.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const glob__default = /*#__PURE__*/_interopDefault(glob);
const fs__default = /*#__PURE__*/_interopDefault(fs);
const semver__default = /*#__PURE__*/_interopDefault(semver);
var _dec, _dec2, _dec3, _class;
let Package = (_dec = common.Memoize(), _dec2 = common.Memoize(), _dec3 = common.Memoize(), (_class = class Package {
  constructor(path, contents, workspaceRoot) {
    this.artifacts = [];
    this.configs = [];
    this.debug = void 0;
    this.json = void 0;
    this.jsonPath = void 0;
    this.path = void 0;
    this.workspaceRoot = void 0;
    this.path = path;
    this.jsonPath = this.path.append('package.json');
    this.json = contents;
    this.workspaceRoot = workspaceRoot ?? path;
    this.debug = debug.createDebugger(['packemon', 'package', this.getSlug()]);
    if (contents.packemon) {
      if (!common.isObject(contents.packemon) && !Array.isArray(contents.packemon)) {
        throw new Error(`Invalid \`packemon\` configuration for ${contents.name}, must be an object or array of objects.`);
      }
      this.setConfigs(common.toArray(contents.packemon));
    }
  }
  async build(options, packemonConfig) {
    this.debug('Building artifacts');

    // Build artifacts in parallel
    const features = this.getFeatureFlags();
    await Promise.all(this.artifacts.map(async artifact => {
      const start = Date.now();
      try {
        artifact.state = 'building';
        await artifact.build(options, features, packemonConfig);
        artifact.state = 'passed';
      } catch (error) {
        artifact.state = 'failed';
        throw error;
      } finally {
        artifact.buildResult.time = Date.now() - start;
      }
    }));

    // Add package entry points based on artifacts
    this.addEntryPoints();

    // Add package `engines` based on artifacts
    if (options.addEngines) {
      this.addEngines();
    }

    // Add package `exports` based on artifacts
    if (options.addExports) {
      this.addExports(features);
    }

    // Add package `files` whitelist
    if (options.addFiles) {
      this.addFiles();
    }

    // Stamp with a timestamp
    if (options.stamp) {
      this.json.release = String(Date.now());
    }

    // Sync `package.json` in case it was modified
    await this.syncJson();
  }
  async clean() {
    this.debug('Cleaning build artifacts');
    await Promise.all(this.artifacts.map(artifact => artifact.clean()));
  }
  async findDistributableFiles() {
    // https://github.com/npm/npm-packlist/blob/main/index.js#L29
    const patterns = ['(readme|copying|license|licence)*', 'package.json'];
    this.json.files?.forEach(file => {
      if (file.endsWith('/')) {
        patterns.push(`${file}**/*`);
      } else {
        patterns.push(file);
      }
    });
    return glob__default.default(patterns, {
      caseSensitiveMatch: false,
      cwd: this.path.path(),
      dot: true,
      ignore: ['node_modules']
    });
  }
  async findSourceFiles() {
    const extsWithoutPeriod = constants.EXTENSIONS.map(ext => ext.slice(1)).join(',');
    const files = await glob__default.default(`src/**/*.{${extsWithoutPeriod}}`, {
      absolute: true,
      cwd: this.path.path(),
      onlyFiles: true,
      // This breaks our own fixtures, so this is hard to test...
      ignore: process.env.NODE_ENV === 'test' ? [] : constants.EXCLUDE
    });
    files.sort();
    return files.map(file => new common.Path(file).path());
  }

  /**
   * Generate artifacts based on the packemon configuration.
   */
  generateArtifacts({
    declaration,
    filterFormats,
    filterPlatforms
  } = {}) {
    this.debug('Generating artifacts');
    const sharedLib = this.requiresSharedLib();
    const apiType = this.determineApiType();
    this.configs.forEach((config, index) => {
      let builds = config.formats.map(format => ({
        declaration,
        format
      }));
      if (filterFormats) {
        this.debug('Filtering formats with pattern: %s', filterFormats);
        builds = builds.filter(build => matchesPattern.matchesPattern(build.format, filterFormats));
      }
      if (filterPlatforms) {
        this.debug('Filtering platforms with pattern: %s', filterPlatforms);
        if (!matchesPattern.matchesPattern(config.platform, filterPlatforms)) {
          return;
        }
      }
      if (builds.length === 0) {
        return;
      }
      const artifact = new Artifact.Artifact(this, builds);
      artifact.api = apiType;
      artifact.bundle = config.bundle;
      artifact.configGroup = index;
      artifact.externals = config.externals;
      artifact.features = config.features;
      artifact.inputs = config.inputs;
      artifact.namespace = config.namespace;
      artifact.platform = config.platform;
      artifact.sharedLib = sharedLib;
      artifact.support = config.support;
      this.artifacts.push(artifact);
      this.debug(' - %s', artifact);
    });
  }
  // eslint-disable-next-line complexity
  getFeatureFlags() {
    this.debug('Loading feature flags');
    const flags = {};

    // React
    if (this.hasDependency('react')) {
      const peerDep = this.json.peerDependencies?.react;
      const prodDep = this.json.dependencies?.react;
      const versionsToCheck = [];
      if (peerDep && peerDep !== '*') {
        versionsToCheck.push(...peerDep.split('||'));
      } else if (prodDep && prodDep !== '*') {
        versionsToCheck.push(prodDep);
      }

      // New JSX transform was backported to these versions:
      // https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html
      const automatic = versionsToCheck.every(version => {
        const coercedVersion = semver__default.default.coerce(version.trim().replace(/(>|<|=|~|^)/g, ''));
        if (coercedVersion === null) {
          return false;
        }
        return semver__default.default.satisfies(coercedVersion.version, '>=17.0.0 || ^16.14.0 || ^15.7.0 || ^0.14.0');
      });
      flags.react = automatic && versionsToCheck.length > 0 ? 'automatic' : 'classic';
      this.debug(' - React');
    }

    // Solid
    if (this.hasDependency('solid-js')) {
      flags.solid = true;
      this.debug(' - Solid');
    }

    // TypeScript
    if (this.hasDependency('typescript') || this.path.append('tsconfig.json').exists() || this.workspaceRoot.append('tsconfig.json').exists()) {
      const tsConfig = loadTsconfigJson.loadTsconfigJson(this.path.append('tsconfig.json'));
      flags.typescript = true;
      flags.typescriptComposite = Boolean(
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      tsConfig?.options?.composite || tsConfig?.projectReferences && tsConfig?.projectReferences.length > 0);
      flags.decorators = Boolean(tsConfig?.options.experimentalDecorators);
      flags.strict = Boolean(tsConfig?.options.strict);
      this.debug(' - TypeScript (%s, %s)', flags.strict ? 'strict' : 'non-strict', flags.decorators ? 'decorators' : 'non-decorators');
    }

    // Flow
    if (this.hasDependency('flow-bin') || this.path.append('.flowconfig').exists() || this.workspaceRoot.append('.flowconfig').exists()) {
      flags.flow = true;
      this.debug(' - Flow');
    }
    return flags;
  }
  getName() {
    return this.json.name;
  }
  getSlug() {
    return this.path.name(true);
  }
  hasDependency(name) {
    const json = this.json;
    return Boolean(json.dependencies?.[name] ?? json.devDependencies?.[name] ?? json.peerDependencies?.[name] ?? json.optionalDependencies?.[name]);
  }
  setConfigs(configs) {
    configs.forEach(cfg => {
      const config = optimal.optimal(schemas.packemonBlueprint, {
        name: this.getName()
      }).validate(cfg);
      common.toArray(config.platform).forEach(platform => {
        let api = config.api,
          bundle = config.bundle;
        let formats = common.toArray(config.format);
        switch (platform) {
          case 'native':
            formats = formats.filter(format => constants.FORMATS_NATIVE.includes(format));
            if (formats.length === 0) {
              formats.push(constants.DEFAULT_FORMATS.native);
            }
            break;
          case 'node':
            if (cfg.api === undefined) {
              api = 'public';
            }
            if (cfg.bundle === undefined) {
              bundle = false;
            }
            formats = formats.filter(format => constants.FORMATS_NODE.includes(format));
            if (formats.length === 0) {
              formats.push(constants.DEFAULT_FORMATS.node);
            }
            break;
          default:
            formats = formats.filter(format => constants.FORMATS_BROWSER.includes(format));
            if (formats.length === 0) {
              formats.push(constants.DEFAULT_FORMATS.browser);
            }
            if (config.namespace && !formats.includes('umd')) {
              formats.push('umd');
            }
            break;
        }
        this.configs.push({
          api,
          bundle,
          externals: common.toArray(config.externals),
          features: config.features,
          formats,
          inputs: config.inputs,
          namespace: config.namespace,
          platform,
          support: config.support
        });
      });
    });
  }
  async syncJson() {
    await fs__default.default.writeJson(this.jsonPath.path(), this.json, {
      spaces: 2
    });
  }
  addEngines() {
    const artifact = this.artifacts.filter(art => art.platform === 'node').reduce((oldest, art) => !oldest || constants.SUPPORT_PRIORITY[art.support] < constants.SUPPORT_PRIORITY[oldest.support] ? art : oldest, null);
    if (!artifact) {
      return;
    }
    this.debug('Adding `engines` to `package.json`');
    if (!this.json.engines) {
      this.json.engines = {};
    }
    Object.assign(this.json.engines, {
      node: `>=${constants.NODE_SUPPORTED_VERSIONS[artifact.support]}`
    });
  }
  addEntryPoints() {
    this.debug('Adding entry points to `package.json`');
    let mainEntry;
    let typesEntry;
    let moduleEntry;
    let browserEntry;

    // eslint-disable-next-line complexity
    this.artifacts.forEach(artifact => {
      const mainEntryName = artifact.getIndexInput();

      // Generate `main`, `module`, and `browser` fields
      if (!mainEntry || artifact.platform === 'node' && mainEntryName === 'index') {
        const entry = artifact.findEntryPoint(['lib', 'cjs', 'mjs', 'esm'], mainEntryName);
        if (entry) {
          mainEntry = entry.entryPath;
          typesEntry = entry.declPath;
        }
      }
      if (!moduleEntry || (artifact.platform === 'browser' || artifact.platform === 'electron') && mainEntryName === 'index') {
        moduleEntry = artifact.findEntryPoint(['esm'], mainEntryName)?.entryPath;
      }

      // Only include when we share a lib with another platform
      if (!browserEntry && (artifact.platform === 'browser' || artifact.platform === 'electron')) {
        browserEntry = artifact.findEntryPoint(artifact.sharedLib ? ['lib', 'umd'] : ['umd'], mainEntryName)?.entryPath;
      }

      // Generate `bin` field
      if (artifact.inputs.bin && artifact.platform === 'node' && !common.isObject(this.json.bin)) {
        this.json.bin = artifact.findEntryPoint(['lib', 'cjs', 'mjs'], 'bin')?.entryPath;
      }
    });
    if (mainEntry) {
      this.json.main = mainEntry;
    }
    if (typesEntry) {
      this.json.types = typesEntry;
    }
    if (moduleEntry) {
      this.json.module = moduleEntry;
    }
    if (browserEntry && !common.isObject(this.json.browser)) {
      this.json.browser = browserEntry;
    }
  }
  addExports(features) {
    this.debug('Adding `exports` to `package.json`');
    let exportMap = {
      './package.json': './package.json'
    };
    this.artifacts.forEach(artifact => {
      Object.entries(artifact.getPackageExports(features)).forEach(([path, conditions]) => {
        if (conditions) {
          exportMap[path] = mergeExports.mergeExports(exportMap[path] ?? {}, conditions);
        }
      });
    });

    // Sort and flatten exports
    exportMap = sortExports.sortExports(exportMap);
    if (common.isObject(this.json.exports)) {
      Object.assign(this.json.exports, exportMap);
    } else {
      this.json.exports = exportMap;
    }
  }
  addFiles() {
    this.debug('Adding files to `package.json`');
    const files = new Set(this.json.files);
    try {
      if (this.path.append('assets').exists()) {
        files.add('assets/**/*');
      }
    } catch {
      // May throw ENOENT
    }
    this.artifacts.forEach(artifact => {
      artifact.builds.forEach(({
        format
      }) => {
        files.add(`${format}/**/*`);
      });
      files.add(`src/**/*`);
    });
    this.json.files = [...files].sort();
  }

  /**
   * When 1 config needs a private API, all other configs should be private,
   * otherwise we will have conflicting output structures and exports.
   */
  determineApiType() {
    return this.configs.some(cfg => cfg.api === 'private') ? 'private' : 'public';
  }

  /**
   * Format "lib" is a shared format across all platforms,
   * and when a package wants to support multiple platforms,
   * we must account for this and alter the output paths.
   */
  requiresSharedLib() {
    const platformsToCheck = new Set();
    let libFormatCount = 0;
    this.configs.forEach(config => {
      platformsToCheck.add(config.platform);
      config.formats.forEach(format => {
        if (format === 'lib') {
          libFormatCount += 1;
        }
      });
    });
    return platformsToCheck.size > 1 && libFormatCount > 1;
  }
}, (_rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "findDistributableFiles", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "findDistributableFiles"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "findSourceFiles", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, "findSourceFiles"), _class.prototype), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "getFeatureFlags", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, "getFeatureFlags"), _class.prototype)), _class));
exports.Package = Package;
//# sourceMappingURL=Package.cjs.map
