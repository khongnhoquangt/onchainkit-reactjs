'use strict';

const fs = require('fs-extra');
const common = require('@boost/common');
const optimal = require('@boost/common/optimal');
const debug = require('@boost/debug');
const Config = require('./Config.cjs');
const matchesPattern = require('./helpers/matchesPattern.cjs');
const Package = require('./Package.cjs');
const PackageValidator = require('./PackageValidator.cjs');
const schemas = require('./schemas.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const fs__default = /*#__PURE__*/_interopDefault(fs);
class Packemon {
  constructor(cwd = process.cwd()) {
    this.config = new Config.Config('packemon');
    this.debug = void 0;
    this.workingDir = void 0;
    this.workingDir = common.Path.resolve(cwd);
    this.debug = debug.createDebugger('packemon:core');
    this.debug('Running packemon in %s', this.workingDir);
  }
  async build(pkg, baseOptions) {
    this.debug('Starting `build` process');
    const options = optimal.optimal(schemas.buildBlueprint).validate(baseOptions);
    pkg.generateArtifacts(options);
    if (options.loadConfigs) {
      const _await$this$config$lo = await this.config.loadConfigFromBranchToRoot(pkg.path),
        config = _await$this$config$lo.config;
      await pkg.build(options, config);
    } else {
      await pkg.build(options, {});
    }
  }
  async clean(pkg) {
    this.debug('Starting `clean` process');
    pkg.generateArtifacts({});
    await pkg.clean();
  }
  async validate(pkg, baseOptions) {
    this.debug('Starting `validate` process');
    const options = optimal.optimal(schemas.validateBlueprint).validate(baseOptions);
    return new PackageValidator.PackageValidator(pkg).validate(options);
  }

  /**
   * Find and load the package that has been configured with a `packemon`
   * block in the `package.json`. Once loaded, validate the configuration.
   */
  async findPackage({
    skipPrivate
  } = {}) {
    this.debug('Finding package in %s', this.workingDir);
    const pkgPath = this.workingDir.append('package.json');
    if (!pkgPath.exists()) {
      throw new Error(`No \`package.json\` found in ${this.workingDir}.`);
    }
    const pkgContents = common.json.parse(await fs__default.default.readFile(pkgPath.path(), 'utf8'));
    if (skipPrivate && pkgContents.private) {
      this.debug('Package is private and `skipPrivate` has been provided');
      return null;
    }
    if (!pkgContents.packemon) {
      this.debug('No `packemon` configuration found for %s, skipping', pkgContents.name);
      return null;
    }
    return new Package.Package(this.workingDir, pkgContents, this.findWorkspaceRoot());
  }

  /**
   * Find all packages within a project. If using workspaces, return a list of packages
   * from each workspace glob. If not using workspaces, assume project is a package.
   */
  async findPackages({
    filter,
    skipPrivate
  } = {}) {
    this.debug('Finding packages in project');
    const workspaceRoot = this.findWorkspaceRoot();
    const project = new common.Project(workspaceRoot);
    const workspaces = project.getWorkspaceGlobs({
      relative: true
    });
    if (workspaces.length === 0) {
      throw new Error('No `workspaces` defined in root `package.json`.');
    }
    const pkgPaths = project.getWorkspacePackagePaths().map(filePath => common.Path.create(filePath).append('package.json'));
    this.debug('Found %d package(s)', pkgPaths.length);
    let packages = [];
    await Promise.all(pkgPaths.map(async pkgPath => {
      if (!pkgPath.exists()) {
        return;
      }
      const contents = common.json.parse(await fs__default.default.readFile(pkgPath.path(), 'utf8'));
      if (contents.packemon) {
        this.debug(' - %s (%s)', contents.name, pkgPath.path());
        packages.push(new Package.Package(pkgPath.parent(), contents, workspaceRoot));
      } else {
        this.debug('No `packemon` configuration found for %s, skipping', contents.name);
      }
    }));

    // Skip `private` packages
    if (skipPrivate) {
      const privatePackageNames = [];
      packages = packages.filter(pkg => {
        if (pkg.json.private) {
          privatePackageNames.push(pkg.getName());
          return false;
        }
        return true;
      });
      this.debug('Filtering private packages: %s', privatePackageNames.join(', '));
    }

    // Filter packages based on a pattern
    if (filter) {
      const filteredPackageNames = [];
      packages = packages.filter(pkg => {
        const name = pkg.getName();
        if (!matchesPattern.matchesPattern(name, filter)) {
          filteredPackageNames.push(name);
          return false;
        }
        return true;
      });
      this.debug('Filtering packages with pattern %s: %s', filter, filteredPackageNames.join(', '));
    }

    // Error if no packages are found
    if (packages.length === 0) {
      throw new Error('No packages found in project.');
    }
    return packages;
  }

  /**
   * Determine the workspace root when running in a monorepo.
   * This is necessary as it changes functionality.
   */
  // eslint-disable-next-line complexity
  findWorkspaceRoot(startingDir) {
    const dir = startingDir ?? this.workingDir;
    if (dir.append('yarn.lock').exists() || dir.append('package-lock.json').exists() || dir.append('pnpm-lock.yaml').exists()) {
      return dir;
    }
    const pkgPath = dir.append('package.json');
    if (pkgPath.exists()) {
      const pkg = common.json.parse(fs__default.default.readFileSync(pkgPath.path(), 'utf8'));
      if (pkg.workspaces) {
        return dir;
      }
    }
    const parentDir = dir.parent();

    // This is a special case to handle our fixtures
    if (process.env.NODE_ENV === 'test' && parentDir.name() === '__fixtures__') {
      return dir;
    }
    const isRoot = parentDir.path();
    if (isRoot === '' || isRoot === '.' || isRoot === '/') {
      return dir; // Oops
    }
    return this.findWorkspaceRoot(parentDir);
  }
}
exports.Packemon = Packemon;
//# sourceMappingURL=Packemon.cjs.map
