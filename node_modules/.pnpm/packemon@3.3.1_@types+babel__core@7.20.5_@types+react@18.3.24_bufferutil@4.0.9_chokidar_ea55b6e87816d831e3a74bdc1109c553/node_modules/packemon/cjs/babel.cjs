'use strict';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const fs = require('fs-extra');
const common = require('@boost/common');
require('./index.cjs');
const constants = require('./constants.cjs');
const config = require('./babel/config.cjs');
const Packemon = require('./Packemon.cjs');
const Package = require('./Package.cjs');
const Artifact = require('./Artifact.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const fs__default = /*#__PURE__*/_interopDefault(fs);
const format = process.env.PACKEMON_FORMAT ?? 'lib';
const support = process.env.PACKEMON_SUPPORT ?? constants.DEFAULT_SUPPORT;
function getBabelConfig(artifact, featureFlags) {
  const inputConfig = config.getBabelInputConfig(artifact, featureFlags, {});
  const outputConfig = config.getBabelOutputConfig(artifact.platform, artifact.support, artifact.builds[0].format, featureFlags, {});
  return {
    // Input must come first
    plugins: [...inputConfig.plugins, ...outputConfig.plugins],
    // Env must come first
    presets: [...outputConfig.presets, ...inputConfig.presets]
  };
}
function createConfig(folder, options = {}) {
  const path = new common.Path(folder);
  const contents = fs__default.default.readJsonSync(path.append('package.json').path());
  const packemon = new Packemon.Packemon();

  // Create package and configs
  const pkg = new Package.Package(path, contents, packemon.findWorkspaceRoot());
  if (pkg.json.packemon) {
    pkg.setConfigs(common.toArray(pkg.json.packemon));
  }

  // Determine the lowest platform to support
  const platforms = pkg.configs.map(config => config.platform);
  let lowestPlatform = 'node';

  // istanbul ignore next
  if (platforms.includes('browser')) {
    lowestPlatform = 'browser';
  } else if (platforms.includes('electron')) {
    lowestPlatform = 'electron';
  } else if (platforms.includes('native')) {
    lowestPlatform = 'native';
  }

  // Generate artifact and builds
  const artifact = new Artifact.Artifact(pkg, [{
    declaration: false,
    format: options.format ?? format
  }]);
  artifact.bundle = false;
  artifact.platform = options.platform ?? lowestPlatform;
  artifact.support = options.support ?? support;
  return getBabelConfig(artifact, pkg.getFeatureFlags());
}
function createRootConfig(options) {
  const config = createConfig(process.cwd(), options);
  return _objectSpread(_objectSpread({}, config), {}, {
    babelrc: false,
    // Support React Native libraries by default
    overrides: [{
      presets: ['@babel/preset-flow'],
      test: /node_modules\/((jest-)?react-native|@react-native(-community)?)/iu
    }]
  });
}
exports.createConfig = createConfig;
exports.createRootConfig = createRootConfig;
//# sourceMappingURL=babel.cjs.map
