'use strict';

const http = require('node:http');
const https = require('node:https');
const execa = require('execa');
const semver = require('semver');
const spdxLicenses = require('spdx-license-list');
const common = require('@boost/common');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const http__default = /*#__PURE__*/_interopDefault(http);
const https__default = /*#__PURE__*/_interopDefault(https);
const execa__default = /*#__PURE__*/_interopDefault(execa);
const semver__default = /*#__PURE__*/_interopDefault(semver);
const spdxLicenses__default = /*#__PURE__*/_interopDefault(spdxLicenses);
class PackageValidator {
  constructor(pkg) {
    this.errors = [];
    this.package = void 0;
    this.warnings = [];
    this.package = pkg;
  }
  hasErrors() {
    return this.errors.length > 0;
  }
  hasWarnings() {
    return this.warnings.length > 0;
  }
  async validate(options) {
    const promises = [];
    if (options.meta) {
      this.checkMetadata();
    }
    if (options.deps) {
      this.checkDependencies();
    }
    if (options.engines) {
      promises.push(this.checkEngines());
    }
    if (options.entries) {
      this.checkEntryPoints();
    }
    if (options.license) {
      this.checkLicense();
    }
    if (options.links) {
      promises.push(this.checkLinks());
    }
    if (options.people) {
      promises.push(this.checkPeople());
    }
    if (options.repo) {
      promises.push(this.checkRepository());
    }
    await Promise.all(promises);
    return this;
  }
  checkDependencies() {
    this.package.debug('Checking dependencies');
    const usesLerna = this.isLernaManaged();
    const workspacePackageNames = new Set(this.getWorkspacePackageNames());
    const _this$package$json = this.package.json,
      _this$package$json$de = _this$package$json.dependencies,
      dependencies = _this$package$json$de === void 0 ? {} : _this$package$json$de,
      _this$package$json$de2 = _this$package$json.devDependencies,
      devDependencies = _this$package$json$de2 === void 0 ? {} : _this$package$json$de2,
      _this$package$json$pe = _this$package$json.peerDependencies,
      peerDependencies = _this$package$json$pe === void 0 ? {} : _this$package$json$pe,
      _this$package$json$op = _this$package$json.optionalDependencies,
      optionalDependencies = _this$package$json$op === void 0 ? {} : _this$package$json$op;
    this.checkDependencyRange(dependencies);
    this.checkDependencyRange(devDependencies);
    this.checkDependencyRange(peerDependencies);
    this.checkDependencyRange(optionalDependencies);
    Object.entries(peerDependencies).forEach(([peerName, versionConstraint]) => {
      const devVersion = semver__default.default.coerce(devDependencies[peerName]);
      const prodVersion = dependencies[peerName];
      if (prodVersion) {
        this.errors.push(`Dependency "${peerName}" defined as both a prod and peer dependency.`);
      }

      // Avoid further checks if constraint is special.
      if (versionConstraint.includes(':')) {
        return;
      }

      // When using Lerna, we want to avoid pairing a peer with a dev dependency,
      // as Lerna will update their `package.json` version of all dependent packages!
      // This would accidently publish many packages that shouldn't be.
      if (usesLerna && workspacePackageNames.has(peerName)) {
        if (devVersion) {
          this.errors.push(`Peer dependency "${peerName}" should not define a dev dependency when using Lerna.`);
        }
        return;
      }
      if (!devVersion) {
        // NOTE: This is useful but causes unnecessary "package changes" when using semantic
        // releases or changesets. Best approach forward?
        // if (!peerDependenciesMeta[peerName]?.optional) {
        // 	this.warnings.push(
        // 		`Peer dependency "${peerName}" is missing a version satisfying dev dependency.`,
        // 	);
        // }
      } else if (!semver__default.default.satisfies(devVersion.version, versionConstraint)) {
        this.errors.push(`Dev dependency "${peerName}" does not satisfy version constraint of its peer. Found ${devVersion.version}, requires ${versionConstraint}.`);
      }
    });
  }
  checkDependencyRange(deps) {
    Object.entries(deps).forEach(([depName, version]) => {
      if (version.startsWith('file:')) {
        this.errors.push(`Dependency "${depName}" must not require the file system. Found "file:" constraint.`);
      } else if (version.startsWith('link:')) {
        this.errors.push(`Dependency "${depName}" must not require symlinks. Found "link:" constraint.`);
      }
    });
  }
  async checkEngines() {
    this.package.debug('Checking engines');
    const engines = this.package.json.engines;
    const nodeConstraint = engines?.node;
    const npmConstraint = engines?.npm;
    const yarnConstraint = engines?.yarn;
    if (nodeConstraint) {
      const nodeVersion = semver__default.default.coerce(await this.getBinVersion('node'));
      if (nodeVersion && !semver__default.default.satisfies(nodeVersion.version, nodeConstraint)) {
        this.warnings.push(`Node.js does not satisfy engine constraints. Found ${nodeVersion.version}, requires ${nodeConstraint}.`);
      }
    }
    if (npmConstraint) {
      const npmVersion = semver__default.default.coerce(await this.getBinVersion('npm'));
      if (npmVersion && !semver__default.default.satisfies(npmVersion.version, npmConstraint)) {
        this.warnings.push(`npm does not satisfy engine constraints. Found ${npmVersion.version}, requires ${npmConstraint}.`);
      }
    }
    if (yarnConstraint) {
      const yarnVersion = semver__default.default.coerce(await this.getBinVersion('yarn'));
      if (yarnVersion && !semver__default.default.satisfies(yarnVersion.version, yarnConstraint)) {
        this.warnings.push(`Yarn does not satisfy engine constraints. Found ${yarnVersion.version}, requires ${yarnConstraint}.`);
      }
    }
  }
  checkEntryPoints() {
    this.package.debug('Checking entry points');
    const _this$package$json2 = this.package.json,
      bin = _this$package$json2.bin,
      man = _this$package$json2.man,
      exp = _this$package$json2.exports;
    PackageValidator.entryPoints.forEach(field => {
      const relPath = this.package.json[field];
      if (!relPath || typeof relPath !== 'string') {
        if (field === 'main' && !exp) {
          this.errors.push('Missing primary entry point. Provide a `main` or `exports` field.');
        }
        return;
      }
      if (!this.doesPathExist(relPath)) {
        this.errors.push(`Entry point "${field}" resolves to an invalid or missing file.`);
      }
    });
    if (common.isObject(bin)) {
      Object.entries(bin).forEach(([name, path]) => {
        if (!this.doesPathExist(path)) {
          this.errors.push(`Bin "${name}" resolves to an invalid or missing file.`);
        }
      });
    }
    if (Array.isArray(man)) {
      man.forEach(path => {
        if (!this.doesPathExist(path)) {
          this.errors.push(`Manual "${path}" resolves to an invalid or missing file.`);
        }
      });
    }
  }
  checkLicense() {
    this.package.debug('Checking license');
    const license = this.package.json.license;
    if (license) {
      if (license === 'UNLICENSED') {
        return;
      }
      const spdxLicenseTypes = new Set(Object.keys(spdxLicenses__default.default).map(key => key.toLocaleLowerCase()));
      common.toArray(typeof license === 'string' ? {
        type: license,
        url: spdxLicenses__default.default[license]
      } : license).forEach(l => {
        if (!spdxLicenseTypes.has(l.type.toLocaleLowerCase())) {
          this.errors.push(`Invalid license "${l.type}". Must be an official SPDX license type.`);
        }
      });
    } else {
      this.errors.push('Missing license.');
    }
    if (!this.doesPathExist('LICENSE') && !this.doesPathExist('LICENSE.md')) {
      this.errors.push('No license file found in package. Must contain one of LICENSE or LICENSE.md.');
    }
  }
  async checkLinks() {
    this.package.debug('Checking links');
    const _this$package$json3 = this.package.json,
      bugs = _this$package$json3.bugs,
      homepage = _this$package$json3.homepage;
    const bugsUrl = common.isObject(bugs) ? bugs.url : bugs;
    if (homepage && !(await this.doesUrlExist(homepage))) {
      this.warnings.push('Homepage link is invalid. URL is either malformed or upstream is down.');
    }
    if (bugsUrl && !(await this.doesUrlExist(bugsUrl))) {
      this.warnings.push('Bugs link is invalid. URL is either malformed or upstream is down.');
    }
  }
  checkMetadata() {
    this.package.debug('Checking metadata');
    const _this$package$json4 = this.package.json,
      name = _this$package$json4.name,
      version = _this$package$json4.version,
      description = _this$package$json4.description,
      keywords = _this$package$json4.keywords,
      isPrivate = _this$package$json4.private;
    if (!name) {
      this.errors.push('Missing name.');
    } else if (!common.isModuleName(name)) {
      this.errors.push('Invalid name format. Must contain alphanumeric characters and dashes.');
    }

    // Only validate name when a private package
    if (isPrivate) {
      return;
    }
    if (!version) {
      this.errors.push('Missing version.');
    }
    if (!description) {
      this.warnings.push('Missing description.');
    }
    if (!keywords || keywords.length === 0) {
      this.warnings.push('Missing keywords.');
    }
    if (!this.doesPathExist('README') && !this.doesPathExist('README.md')) {
      this.errors.push('No read me found in package. Must contain one of README or README.md.');
    }
  }
  async checkPeople() {
    this.package.debug('Checking author and contributors');
    const _this$package$json5 = this.package.json,
      author = _this$package$json5.author,
      contributors = _this$package$json5.contributors;
    if (!author) {
      this.warnings.push('Missing author.');
    } else if (common.isObject(author)) {
      if (!author.name) {
        this.errors.push('Missing author name.');
      }
      if (author.url && !(await this.doesUrlExist(author.url))) {
        this.warnings.push('Author URL is invalid. URL is either malformed or upstream is down.');
      }
    }
    if (Array.isArray(contributors)) {
      await Promise.all(contributors.map(async contrib => {
        if (typeof contrib === 'string') {
          return;
        }
        if (!contrib.name) {
          this.errors.push('Missing contributor name.');
        }
        if (contrib.url && !(await this.doesUrlExist(contrib.url))) {
          this.warnings.push('Contributor URL is invalid. URL is either malformed or upstream is down.');
        }
      }));
    } else if (contributors) {
      this.warnings.push('Contributors must be an array.');
    }
  }
  async checkRepository() {
    this.package.debug('Checking repository');
    const repo = this.package.json.repository;
    const url = common.isObject(repo) ? repo.url : repo;
    if (!url) {
      this.errors.push('Missing repository.');
    } else if (url.startsWith('http') && !(await this.doesUrlExist(url))) {
      this.warnings.push('Repository is invalid. URL is either malformed or upstream is down.');
    }
    if (common.isObject(repo)) {
      const dir = repo.directory;
      if (dir && !this.package.workspaceRoot.append(dir).exists()) {
        this.errors.push(`Repository directory "${dir}" does not exist.`);
      }
    }
  }
  doesPathExist(path) {
    return this.package.path.append(path).exists();
  }

  // istanbul ignore next
  async doesUrlExist(url) {
    return new Promise(resolve => {
      const request = url.startsWith('https') ? https__default.default.request : http__default.default.request;
      const ping = request(url, () => {
        resolve(true);
        ping.abort();
      });
      ping.on('error', () => {
        resolve(false);
        ping.abort();
      });
      ping.write('');
      ping.end();
    });
  }
  async getBinVersion(bin) {
    try {
      return (await execa__default.default(bin, ['-v'], {
        preferLocal: true
      })).stdout.trim();
    } catch {
      // istanbul ignore next
      return '';
    }
  }
  getWorkspacePackageNames() {
    return new common.Project(this.package.workspaceRoot).getWorkspacePackages().map(wp => wp.package.name);
  }
  isLernaManaged() {
    return this.package.workspaceRoot.append('lerna.json').exists();
  }
}
PackageValidator.entryPoints = ['main', 'module', 'browser', 'types', 'typings', 'bin', 'man'];
exports.PackageValidator = PackageValidator;
//# sourceMappingURL=PackageValidator.cjs.map
