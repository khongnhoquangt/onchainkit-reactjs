'use strict';

const react$1 = require('react');
const ink = require('ink');
const react = require('@boost/cli/react');
const Symbol = require('./Symbol.cjs');
const TreeContext = require('./TreeContext.cjs');
const jsxRuntime = require('react/jsx-runtime');

/* eslint-disable react-perf/jsx-no-new-array-as-prop */

const FOLDER_COLOR = {
  src: 'notice',
  // Node.js
  cjs: 'success',
  mjs: 'success',
  // JavaScript
  lib: 'warning',
  esm: 'warning',
  umd: 'warning',
  // TypeScript
  dts: 'info'
};
function FileList({
  depth,
  files,
  hasFolders
}) {
  const _TreeContext$useTree = TreeContext.useTree(),
    lastIndex = _TreeContext$useTree.lastIndex;
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: files.map((file, index) => /*#__PURE__*/jsxRuntime.jsxs(ink.Box, {
      children: [/*#__PURE__*/jsxRuntime.jsx(Symbol.Symbol, {
        depth: depth,
        first: depth.length === 0 && index === 0 && !hasFolders,
        last: lastIndex[0] === 'file' && lastIndex[1] === index
      }), /*#__PURE__*/jsxRuntime.jsx(ink.Text, {
        children: file
      })]
    }, file + String(depth)))
  });
}
function FolderList({
  depth,
  folders,
  hasFiles = false
}) {
  const _TreeContext$useTree2 = TreeContext.useTree(),
    folderStyle = _TreeContext$useTree2.folderStyle,
    lastIndex = _TreeContext$useTree2.lastIndex;
  const lastFolderIndex = folders.length - 1;
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: folders.map(([folder, tree], index) => {
      const style = folderStyle ?? FOLDER_COLOR[folder] ?? 'failure';
      return /*#__PURE__*/jsxRuntime.jsxs(ink.Box, {
        flexDirection: "column",
        children: [/*#__PURE__*/jsxRuntime.jsxs(ink.Box, {
          children: [/*#__PURE__*/jsxRuntime.jsx(Symbol.Symbol, {
            depth: depth,
            first: depth.length === 0 && index === 0,
            last: lastIndex[0] === 'folder' && lastIndex[1] === index
          }), /*#__PURE__*/jsxRuntime.jsx(react.Style, {
            bold: true,
            type: style,
            children: folder
          })]
        }), /*#__PURE__*/jsxRuntime.jsx(Tree, {
          depth: [...depth, index === lastFolderIndex ? hasFiles : true],
          style: style,
          tree: tree
        })]
      }, folder + String(depth));
    })
  });
}
function Tree({
  depth = [],
  tree,
  style
}) {
  const files = (tree.files ?? []).sort((a, b) => a.localeCompare(b));
  const folders = Object.entries(tree.folders ?? {}).sort((a, b) => a[0].localeCompare(b[0]));
  const value = react$1.useMemo(() => ({
    folderStyle: style,
    lastIndex: files.length > 0 ? ['file', files.length - 1] : ['folder', folders.length - 1]
  }), [files, folders, style]);
  return /*#__PURE__*/jsxRuntime.jsx(TreeContext.TreeContext.Provider, {
    value: value,
    children: /*#__PURE__*/jsxRuntime.jsxs(ink.Box, {
      flexDirection: "column",
      children: [folders.length > 0 && /*#__PURE__*/jsxRuntime.jsx(FolderList, {
        depth: depth,
        folders: folders,
        hasFiles: files.length > 0
      }), files.length > 0 && /*#__PURE__*/jsxRuntime.jsx(FileList, {
        depth: depth,
        files: files,
        hasFolders: folders.length > 0
      })]
    })
  });
}
exports.Tree = Tree;
//# sourceMappingURL=Tree.cjs.map
