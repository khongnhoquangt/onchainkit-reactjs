'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const common = require('@boost/common');
const TranslateError = require('./TranslateError.cjs');
const EXTS = {
  js: ['js'],
  json: ['json', 'json5'],
  yaml: ['yaml', 'yml']
};
class FileBackend extends common.Contract {
  constructor(...args) {
    super(...args);
    this.fileCache = new Map();
    this.type = 'backend';
  }
  init(services, options) {
    this.configure(options);

    // Validate resource paths are directories
    this.options.paths.forEach(path => {
      if (path.exists() && !path.isDirectory()) {
        throw new TranslateError.TranslateError('RESOURCE_PATH_INVALID', [path.path()]);
      }
    });
  }
  blueprint(schemas) {
    const array = schemas.array,
      instance = schemas.instance,
      string = schemas.string;
    return {
      format: string('yaml').oneOf(['js', 'json', 'yaml']),
      paths: array().of(instance().of(common.Path, {
        loose: true
      }).notNullable())
    };
  }

  // istanbul ignore next
  create() {
    // We don't need this but is required by the interface
  }
  read(locale, namespace, handler) {
    const _this$options = this.options,
      format = _this$options.format,
      paths = _this$options.paths;
    const resources = {};
    paths.forEach(path => {
      EXTS[format].some(ext => {
        const resPath = path.append(locale, `${namespace}.${ext}`);
        const isCached = this.fileCache.has(resPath);
        if (!resPath.exists()) {
          return false;
        }
        if (!isCached) {
          let content;
          switch (ext) {
            case 'yml':
            case 'yaml':
              content = common.yaml.load(resPath);
              break;
            case 'json':
            case 'json5':
              content = common.json.load(resPath);
              break;
            default:
              content = require(resPath.path());
              break;
          }
          this.fileCache.set(resPath, content);
        }
        Object.assign(resources, this.fileCache.get(resPath));
        return true;
      });
    });
    handler(null, resources);
    return resources;
  }
}
exports.FileBackend = FileBackend;
//# sourceMappingURL=FileBackend.cjs.map
