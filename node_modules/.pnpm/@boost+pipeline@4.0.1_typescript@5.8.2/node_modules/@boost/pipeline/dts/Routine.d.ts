import execa, { ExecaChildProcess, Options as ExecaOptions } from 'execa';
import { Debugger } from '@boost/debug';
import { Event } from '@boost/event';
import { AggregatedPipeline } from './AggregatedPipeline';
import { ConcurrentPipeline } from './ConcurrentPipeline';
import { Context } from './Context';
import { Monitor } from './Monitor';
import { PooledOptions, PooledPipeline } from './PooledPipeline';
import { AnyWorkUnit, Hierarchical } from './types';
import { WaterfallPipeline } from './WaterfallPipeline';
import { WorkUnit } from './WorkUnit';
export interface ExecuteCommandOptions {
    wrap?: (process: ExecaChildProcess) => void;
    workUnit?: AnyWorkUnit;
}
export declare abstract class Routine<Output = unknown, Input = unknown, Options extends object = {}> extends WorkUnit<Options, Input, Output> {
    readonly debug: Debugger;
    readonly key: string;
    /**
     * Called after `execa` was executed.
     * @category Events
     */
    readonly onCommand: Event<[string, string[]], string>;
    /**
     * Called while a command is being executed.
     * @category Events
     */
    readonly onCommandData: Event<[string, string], string>;
    protected monitorInstance: Monitor | null;
    constructor(key: string[] | string, title: string, options?: Options);
    /**
     * Execute a command with the given arguments and pass the results through a promise.
     */
    executeCommand(command: string, args: string[], options?: ExecaOptions & ExecuteCommandOptions): Promise<execa.ExecaReturnValue<string>>;
    /**
     * Create and return a `AggregatedPipeline`. This pipeline will execute all work units
     * in parallel without interruption. Returns an object with a list of errors and results
     * once all resolve.
     */
    createAggregatedPipeline<C extends Context, I = unknown, O = I>(context: C, value?: I): AggregatedPipeline<C, I, O>;
    /**
     * Create and return a `ConcurrentPipeline`. This pipeline will execute all work units
     * in parallel. Returns a list of values once all resolve.
     */
    createConcurrentPipeline<C extends Context, I = unknown, O = I>(context: C, value?: I): ConcurrentPipeline<C, I, O>;
    /**
     * Create and return a `PooledPipeline`. This pipeline will execute a distinct set of work units
     * in parallel without interruption, based on a max concurrency, until all work units have ran.
     * Returns a list of errors and results once all resolve.
     */
    createPooledPipeline<C extends Context, I = unknown, O = I>(context: C, value?: I, options?: PooledOptions): PooledPipeline<C, I, O>;
    /**
     * Create and return a `WaterfallPipeline`. This pipeline will execute each work unit one by one,
     * with the return value of the previous being passed to the next. Returns the final value once
     * all resolve.
     */
    createWaterfallPipeline<C extends Context, I = unknown>(context: C, value?: I): WaterfallPipeline<C, I>;
    /**
     * Set the monitor to pass to nested pipelines.
     */
    setMonitor(monitor: Monitor): this;
    /**
     * Update the hierarchical depth when creating a nested pipeline.
     */
    protected updateHierarchy<P extends Hierarchical>(pipeline: P): P;
    /**
     * Execute the current routine and return a new value.
     */
    abstract execute(context: Context, value: Input): Promise<Output>;
}
//# sourceMappingURL=Routine.d.ts.map