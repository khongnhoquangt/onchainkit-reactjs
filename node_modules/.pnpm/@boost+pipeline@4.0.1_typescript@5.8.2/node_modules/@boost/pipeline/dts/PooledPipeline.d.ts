import { Blueprint, Schemas } from '@boost/common/optimal';
import { Context } from './Context';
import { ParallelPipeline } from './ParallelPipeline';
import { AggregatedResult } from './types';
import { WorkUnit } from './WorkUnit';
export interface PooledOptions {
    /** How many work units to process in parallel. */
    concurrency?: number;
    /** Process with first-in-last-out order, instead of first-in-first-out. */
    filo?: boolean;
    /** Timeout in milliseconds that each work unit may run, or `0` to avoid a
  timeout. Defaults to `0`. */
    timeout?: number;
}
export declare class PooledPipeline<Ctx extends Context, Input = unknown, Output = Input> extends ParallelPipeline<PooledOptions, Ctx, Input, Output> {
    protected resolver?: (response: AggregatedResult<Output>) => void;
    protected results: (Error | Output)[];
    protected running: WorkUnit<{}, Input, Output>[];
    blueprint(schemas: Schemas): Blueprint<PooledOptions>;
    /**
     * Execute all work units in parallel, in a pool with a max concurrency,
     * with a value being passed to each work unit.
     * Work units will synchronize regardless of race conditions and errors.
     */
    run(): Promise<AggregatedResult<Output>>;
    /**
     * Run a single work unit from the queue, and start the next work unit when it passes or fails.
     */
    protected runWorkUnit(context: Ctx, value: Input): Promise<void>;
}
//# sourceMappingURL=PooledPipeline.d.ts.map