import { Blueprint, Schemas } from '@boost/common/optimal';
import { Context } from './Context';
import { Pipeline } from './Pipeline';
import { Action } from './types';
import { WorkUnit } from './WorkUnit';
export declare abstract class SerialPipeline<Options extends object, Ctx extends Context, Input = unknown, Output = Input> extends Pipeline<Options, Ctx, Input, Output> {
    root: SerialPipeline<Options, Ctx, any>;
    blueprint(schemas: Schemas): Blueprint<object>;
    /**
     * Pipe a work unit to be ran with the return value of the previous work unit.
     */
    pipe<O>(title: string, action: Action<Ctx, Input, O>, scope?: unknown): SerialPipeline<Options, Ctx, O>;
    pipe<O>(workUnit: WorkUnit<{}, Input, O>): SerialPipeline<Options, Ctx, O>;
    /**
     * Traverse the linked list to return a list of work units in defined order.
     */
    getWorkUnits(): WorkUnit<{}, Input, Output>[];
    /**
     * Run and process the work units synchronously.
     */
    abstract run(): Promise<Output>;
}
//# sourceMappingURL=SerialPipeline.d.ts.map