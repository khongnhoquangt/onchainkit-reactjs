'use strict';

const _excluded = ["wrap", "workUnit"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const execa = require('execa');
const kebabCase = require('lodash/kebabCase');
const split = require('split');
const common = require('@boost/common');
const debug = require('@boost/debug');
const event = require('@boost/event');
const AggregatedPipeline = require('./AggregatedPipeline.cjs');
const ConcurrentPipeline = require('./ConcurrentPipeline.cjs');
const debug$1 = require('./debug.cjs');
const Pipeline = require('./Pipeline.cjs');
const PipelineError = require('./PipelineError.cjs');
const PooledPipeline = require('./PooledPipeline.cjs');
const WaterfallPipeline = require('./WaterfallPipeline.cjs');
const WorkUnit = require('./WorkUnit.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const execa__default = /*#__PURE__*/_interopDefault(execa);
const kebabCase__default = /*#__PURE__*/_interopDefault(kebabCase);
const split__default = /*#__PURE__*/_interopDefault(split);
class Routine extends WorkUnit.WorkUnit {
  constructor(key, title, options) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    super(title, (context, value) => this.execute(context, value), options);
    this.debug = void 0;
    this.key = void 0;
    /**
     * Called after `execa` was executed.
     * @category Events
     */
    this.onCommand = new event.Event('command');
    /**
     * Called while a command is being executed.
     * @category Events
     */
    this.onCommandData = new event.Event('command-data');
    this.monitorInstance = null;
    if (!key || key.length === 0 || typeof key !== 'string' && !Array.isArray(key)) {
      throw new PipelineError.PipelineError('ROUTINE_INVALID_KEY');
    }
    this.key = common.toArray(key).map(kebabCase__default.default).join(':');
    this.debug = debug.createDebugger(['routine', this.key]);
    debug$1.debug('New routine created: %s (%s)', this.key, this.title);
  }

  /**
   * Execute a command with the given arguments and pass the results through a promise.
   */
  async executeCommand(command, args, options = {}) /* infer */{
    const wrap = options.wrap,
      workUnit = options.workUnit,
      opts = _objectWithoutProperties(options, _excluded);
    const stream = execa__default.default(command, args, opts);
    this.onCommand.emit([command, args]);

    // Push chunks to the reporter
    const unit = workUnit ?? this;
    const handler = line => {
      if (unit.isRunning()) {
        // Only capture the status when not empty
        if (line) {
          unit.statusText = line;
        }
        this.onCommandData.emit([command, line]);
      }
    };
    stream.stderr.pipe(split__default.default()).on('data', handler);
    stream.stdout.pipe(split__default.default()).on('data', handler);

    // Allow consumer to wrap functionality
    if (typeof wrap === 'function') {
      wrap(stream);
    }
    return stream;
  }

  /**
   * Create and return a `AggregatedPipeline`. This pipeline will execute all work units
   * in parallel without interruption. Returns an object with a list of errors and results
   * once all resolve.
   */
  createAggregatedPipeline(context, value) {
    return this.updateHierarchy(new AggregatedPipeline.AggregatedPipeline(context, value));
  }

  /**
   * Create and return a `ConcurrentPipeline`. This pipeline will execute all work units
   * in parallel. Returns a list of values once all resolve.
   */
  createConcurrentPipeline(context, value) {
    return this.updateHierarchy(new ConcurrentPipeline.ConcurrentPipeline(context, value));
  }

  /**
   * Create and return a `PooledPipeline`. This pipeline will execute a distinct set of work units
   * in parallel without interruption, based on a max concurrency, until all work units have ran.
   * Returns a list of errors and results once all resolve.
   */
  createPooledPipeline(context, value, options) {
    return this.updateHierarchy(new PooledPipeline.PooledPipeline(context, value, options));
  }

  /**
   * Create and return a `WaterfallPipeline`. This pipeline will execute each work unit one by one,
   * with the return value of the previous being passed to the next. Returns the final value once
   * all resolve.
   */
  createWaterfallPipeline(context, value) {
    return this.updateHierarchy(new WaterfallPipeline.WaterfallPipeline(context, value));
  }

  /**
   * Set the monitor to pass to nested pipelines.
   */
  setMonitor(monitor) {
    this.monitorInstance = monitor;
    return this;
  }

  /**
   * Update the hierarchical depth when creating a nested pipeline.
   */
  updateHierarchy(pipeline) {
    // eslint-disable-next-line no-param-reassign
    pipeline.depth = this.depth + 1;
    if (this.monitorInstance && pipeline instanceof Pipeline.Pipeline) {
      pipeline.monitor(this.monitorInstance);
    }
    return pipeline;
  }

  /**
   * Execute the current routine and return a new value.
   */
}

exports.Routine = Routine;
//# sourceMappingURL=Routine.cjs.map
