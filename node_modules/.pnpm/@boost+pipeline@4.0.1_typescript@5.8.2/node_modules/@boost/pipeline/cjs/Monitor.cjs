'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const event = require('@boost/event');
const Routine = require('./Routine.cjs');

/* eslint-disable promise/prefer-await-to-callbacks */
class Monitor {
  constructor() {
    /**
     * Called after a pipeline class has ran.
     * @category Events
     */
    this.onPipelineAfterRun = new event.Event('after-run');
    /**
     * Called before a pipeline class is ran.
     * @category Events
     */
    this.onPipelineBeforeRun = new event.Event('before-run');
    /**
     * Called before a pipeline's work unit is executed.
     * @category Events
     */
    this.onPipelineRunWorkUnit = new event.Event('run-work-unit');
    /**
     * Called when any work unit has failed.
     * @category Events
     */
    this.onWorkUnitFail = new event.Event('fail');
    /**
     * Called when any work unit has passed.
     * @category Events
     */
    this.onWorkUnitPass = new event.Event('pass');
    /**
     * Called when any work unit is ran.
     * @category Events
     */
    this.onWorkUnitRun = new event.BailEvent('run');
    /**
     * Called when any work unit is skipped.
     * @category Events
     */
    this.onWorkUnitSkip = new event.Event('skip');
  }
  /**
   * Monitor events for the provided pipeline, its work units, and all other
   * pipelines and work units down the hierarchical tree.
   */
  monitor(pipeline) {
    pipeline.onAfterRun.listen(() => {
      this.onPipelineAfterRun.emit([pipeline]);
    });
    pipeline.onBeforeRun.listen(input => {
      this.onPipelineBeforeRun.emit([pipeline, input]);
    });
    pipeline.onRunWorkUnit.listen((workUnit, value) => {
      if (workUnit instanceof Routine.Routine) {
        workUnit.setMonitor(this);
      }
      this.onPipelineRunWorkUnit.emit([pipeline, workUnit, value]);
      workUnit.onFail.listen((error, input) => {
        this.onWorkUnitFail.emit([workUnit, error, input]);
      });
      workUnit.onPass.listen((output, input) => {
        this.onWorkUnitPass.emit([workUnit, output, input]);
      });
      workUnit.onRun.listen(input => {
        this.onWorkUnitRun.emit([workUnit, input]);
      });
      workUnit.onSkip.listen(input => {
        this.onWorkUnitSkip.emit([workUnit, input]);
      });
    });
    return this;
  }
}
exports.Monitor = Monitor;
//# sourceMappingURL=Monitor.cjs.map
