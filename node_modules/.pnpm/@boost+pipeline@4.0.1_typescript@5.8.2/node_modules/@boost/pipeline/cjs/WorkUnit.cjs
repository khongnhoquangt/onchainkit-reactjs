'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const common = require('@boost/common');
const event = require('@boost/event');
const constants = require('./constants.cjs');
const PipelineError = require('./PipelineError.cjs');
class WorkUnit extends common.Contract {
  // We want to support all contexts, so we use any.
  // Unknown and `Context` will not work because of the constraint.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(title, action, options) {
    super(options);
    this.depth = 0;
    this.index = 0;
    this.output = void 0;
    this.input = void 0;
    this.startTime = 0;
    this.statusText = '';
    this.stopTime = 0;
    /**
     * Called when an execution fails.
     * @category Events
     */
    this.onFail = new event.Event('fail');
    /**
     * Called when an execution succeeds.
     * @category Events
     */
    this.onPass = new event.Event('pass');
    /**
     * Called before a work unit is executed. Can return `true` to skip the work unit.
     * @category Events
     */
    this.onRun = new event.BailEvent('run');
    /**
     * Called when an execution is skipped.
     * @category Events
     */
    this.onSkip = new event.Event('skip');
    this.title = void 0;
    this.action = void 0;
    this.status = constants.STATUS_PENDING;
    if (!title || typeof title !== 'string') {
      throw new PipelineError.PipelineError('WORK_REQUIRED_TITLE');
    }
    if (action !== null && typeof action !== 'function') {
      throw new PipelineError.PipelineError('ACTION_REQUIRED');
    }
    this.action = action;
    this.status = constants.STATUS_PENDING;
    this.title = title;
  }

  /**
   * Return a unique hierarchical ID.
   */
  get id() {
    return `work[${this.depth}:${this.index}]`;
  }

  /**
   * Return true if the task failed when executing.
   */
  hasFailed() {
    return this.status === constants.STATUS_FAILED;
  }

  /**
   * Return true if the task executed successfully.
   */
  hasPassed() {
    return this.status === constants.STATUS_PASSED;
  }

  /**
   * Return true if the task has been completed in any form.
   */
  isComplete() {
    return this.hasPassed() || this.hasFailed() || this.isSkipped();
  }

  /**
   * Return true if the task has not been executed yet.
   */
  isPending() {
    return this.status === constants.STATUS_PENDING;
  }

  /**
   * Return true if the task is currently running.
   */
  isRunning() {
    return this.status === constants.STATUS_RUNNING;
  }

  /**
   * Return true if the task was or will be skipped.
   */
  isSkipped() {
    return this.status === constants.STATUS_SKIPPED;
  }

  /**
   * Run the current task by executing it and performing any before and after processes.
   */
  async run(context, value) {
    this.input = value;
    const skip = this.onRun.emit([value]);
    const runner = this.action;
    if (skip || this.isSkipped() || !runner) {
      this.status = constants.STATUS_SKIPPED;
      this.onSkip.emit([value]);

      // Allow input as output. This is problematic for skipping
      // since the expected output is no longer in sync. Revisit.
      // @ts-expect-error Allow invalid type
      return value;
    }
    this.status = constants.STATUS_RUNNING;
    this.startTime = Date.now();
    try {
      this.output = await runner(context, value, this);
      this.status = constants.STATUS_PASSED;
      this.stopTime = Date.now();
      this.onPass.emit([this.output, value]);
    } catch (error) {
      this.status = constants.STATUS_FAILED;
      this.stopTime = Date.now();
      if (error instanceof Error) {
        this.onFail.emit([error, value]);
        throw error;
      }
    }
    this.statusText = '';
    return this.output;
  }

  /**
   * Mark a task as skipped if the condition is true.
   */
  skip(condition = true) {
    if (condition) {
      this.status = constants.STATUS_SKIPPED;
    }
    return this;
  }
}
exports.WorkUnit = WorkUnit;
//# sourceMappingURL=WorkUnit.cjs.map
