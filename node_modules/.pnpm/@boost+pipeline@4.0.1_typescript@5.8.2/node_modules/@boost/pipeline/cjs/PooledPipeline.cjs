'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const os = require('os');
const debug = require('./debug.cjs');
const ParallelPipeline = require('./ParallelPipeline.cjs');
const PipelineError = require('./PipelineError.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const os__default = /*#__PURE__*/_interopDefault(os);

/* eslint-disable promise/prefer-await-to-callbacks */
class PooledPipeline extends ParallelPipeline.ParallelPipeline {
  constructor(...args) {
    super(...args);
    this.resolver = void 0;
    this.results = [];
    this.running = [];
  }
  blueprint(schemas) {
    const bool = schemas.bool,
      number = schemas.number;
    return {
      concurrency: number(os__default.default.cpus().length).gte(1),
      filo: bool(),
      timeout: number(0).gte(0)
    };
  }

  /**
   * Execute all work units in parallel, in a pool with a max concurrency,
   * with a value being passed to each work unit.
   * Work units will synchronize regardless of race conditions and errors.
   */
  async run() {
    debug.debug('Running %d as a pool', this.work.length);
    this.onBeforeRun.emit([this.value]);
    const result = await new Promise(resolve => {
      if (this.work.length === 0) {
        resolve(this.aggregateResult([]));
        return;
      }
      this.resolver = resolve;
      void Promise.all(this.work.slice(0, this.options.concurrency).map(() => this.runWorkUnit(this.context, this.value)));
    });
    this.onAfterRun.emit([]);
    return result;
  }

  /**
   * Run a single work unit from the queue, and start the next work unit when it passes or fails.
   */
  async runWorkUnit(context, value) {
    const _this$options = this.options,
      concurrency = _this$options.concurrency,
      filo = _this$options.filo,
      timeout = _this$options.timeout;
    const unit = filo ? this.work.pop() : this.work.shift();
    this.running.push(unit);
    const handleResult = result => {
      this.running = this.running.filter(running => running !== unit);
      this.results.push(result);
      if (this.work.length > 0 && this.running.length < concurrency) {
        return this.runWorkUnit(context, value);
      }
      if (this.work.length === 0 && this.running.length === 0 && this.resolver) {
        this.resolver(this.aggregateResult(this.results));
      }
      return Promise.resolve();
    };
    return new Promise(resolve => {
      let timer;
      if (timeout > 0) {
        timer = setTimeout(() => {
          resolve(handleResult(new PipelineError.PipelineError('WORK_TIME_OUT')));
        }, timeout);
      }
      this.onRunWorkUnit.emit([unit, value]);
      unit.run(context, value).then(result => {
        if (timer) {
          clearTimeout(timer);
        }
        resolve(handleResult(result));
        return result;
      }).catch(error => {
        resolve(handleResult(error));
      });
    });
  }
}
exports.PooledPipeline = PooledPipeline;
//# sourceMappingURL=PooledPipeline.cjs.map
