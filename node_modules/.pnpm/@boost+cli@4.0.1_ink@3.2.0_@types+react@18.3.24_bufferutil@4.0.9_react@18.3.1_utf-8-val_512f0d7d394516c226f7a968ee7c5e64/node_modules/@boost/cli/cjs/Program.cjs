'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const levenary = require('levenary');
const args = require('@boost/args');
const common = require('@boost/common');
const event = require('@boost/event');
const internal = require('@boost/internal');
const log = require('@boost/log');
const CLIError = require('./CLIError.cjs');
const CommandManager = require('./CommandManager.cjs');
const Wrapper = require('./components/internal/Wrapper.cjs');
const constants = require('./constants.cjs');
const isArgvSize = require('./helpers/isArgvSize.cjs');
const mapCommandMetadata = require('./helpers/mapCommandMetadata.cjs');
const patchDebugModule = require('./helpers/patchDebugModule.cjs');
const LogBuffer = require('./LogBuffer.cjs');
const getConstructor = require('./metadata/getConstructor.cjs');
const removeProcessBin = require('./middleware/removeProcessBin.cjs');
require('./react.cjs');
const translate = require('./translate.cjs');
const IndexHelp = require('./components/IndexHelp.cjs');
const Help = require('./components/Help.cjs');
const Failure = require('./components/Failure.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const levenary__default = /*#__PURE__*/_interopDefault(levenary);
class Program extends CommandManager.CommandManager {
  constructor(options, streams) {
    super(options);
    /**
     * Called after a component has rendered.
     * @category Events
     */
    this.onAfterRender = new event.Event('after-render');
    /**
     * Called after the program and command have been ran.
     * @category Events
     */
    this.onAfterRun = new event.Event('after-run');
    /**
     * Called after a command has run but before a component will render.
     * @category Events
     */
    this.onBeforeRender = new event.Event('before-render');
    /**
     * Called before the program and command will run.
     * @category Events
     */
    this.onBeforeRun = new event.Event('before-run');
    /**
     * Called when a command has been found after parsing argv.
     * @category Events
     */
    this.onCommandFound = new event.Event('command-found');
    /**
     * Called when a command wasn't found after parsing argv.
     * @category Events
     */
    this.onCommandNotFound = new event.Event('command-not-found');
    /**
     * Called when the exit() handler is executed but before the process exits.
     * @category Events
     */
    this.onExit = new event.Event('exit');
    /**
     * Called when the help menu is rendered.
     * @category Events
     */
    this.onHelp = new event.Event('help');
    this.streams = {
      stderr: process.stderr,
      stdin: process.stdin,
      stdout: process.stdout
    };
    this.commandLine = '';
    this.logger = void 0;
    this.middlewares = [removeProcessBin.removeProcessBin()];
    this.rendering = false;
    this.sharedCategories = {
      global: {
        name: translate.msg('cli:categoryGlobal'),
        weight: 100
      }
    };
    this.standAlone = '';
    this.errBuffer = void 0;
    this.outBuffer = void 0;
    /**
     * Exit the program with an error code.
     * Should be called within a command or component.
     */
    this.exit = (error, errorCode) => {
      let message = '';
      let code = errorCode;
      if (error instanceof common.ExitError) {
        message = error.message;
        code = error.code;
      } else if (error instanceof Error) {
        message = error.message;
      } else if (error) {
        message = error;
      }
      if (!code) {
        code = message ? constants.EXIT_FAIL : constants.EXIT_PASS;
      }
      this.onExit.emit([message, code]);
      throw new common.ExitError(message, code);
    };
    /**
     * Deeply register all commands so that we can easily access it during parse.
     */
    this.handleAfterRegister = (_path, command) => {
      const deepRegister = cmd => {
        const _cmd$getMetadata = cmd.getMetadata(),
          aliases = _cmd$getMetadata.aliases,
          commands = _cmd$getMetadata.commands,
          path = _cmd$getMetadata.path;
        this.commands[path] = cmd;
        aliases.forEach(alias => {
          this.commandAliases[alias] = path;
        });
        Object.values(commands).forEach(deepRegister);
      };
      deepRegister(command);
    };
    /**
     * Check for default and non-default command mixing.
     */
    this.handleBeforeRegister = () => {
      if (this.standAlone) {
        throw new CLIError.CLIError('COMMAND_MIXED_DEFAULT');
      }
    };
    Object.assign(this.streams, streams);

    // Buffers logs during the Ink rendering process
    this.errBuffer = new LogBuffer.LogBuffer(this.streams.stderr);
    this.outBuffer = new LogBuffer.LogBuffer(this.streams.stdout);

    // Both logger and global console will write to the buffers
    this.logger = log.createLogger({
      name: 'cli',
      transports: [new log.StreamTransport({
        format: log.formats.console,
        levels: ['error', 'trace', 'warn'],
        stream: this.errBuffer
      }), new log.StreamTransport({
        format: log.formats.console,
        levels: ['debug', 'info', 'log'],
        stream: this.outBuffer
      })]
    });
    this.onAfterRegister.listen(this.handleAfterRegister);
    this.onBeforeRegister.listen(this.handleBeforeRegister);
  }
  blueprint(schemas) {
    const string = schemas.string;
    return {
      banner: string(),
      bin: string().notEmpty().required().kebabCase(),
      delimiter: string(constants.DELIMITER),
      footer: string(),
      header: string(),
      name: string().notEmpty().required(),
      version: string().required().match(constants.VERSION_FORMAT)
    };
  }

  /**
   * Define option and command categories to supply to the running command,
   * or the program itself.
   */
  categories(categories) {
    Object.assign(this.sharedCategories, categories);
    return this;
  }

  /**
   * Register a command and its canonical path as the default command.
   * A default command should be used when stand-alone binary is required.
   */
  default(command) {
    if (Object.keys(this.commands).length > 0) {
      throw new CLIError.CLIError('COMMAND_MIXED_NONDEFAULT');
    }
    this.register(command);
    this.standAlone = command.getPath();
    return this;
  }
  /**
   * Define a middleware function to apply to the argv list or args object.
   */
  middleware(middleware) {
    if (typeof middleware !== 'function') {
      throw new CLIError.CLIError('MIDDLEWARE_INVALID');
    }
    this.middlewares.push(middleware);
    return this;
  }

  /**
   * Parse the arguments list according to the number of commands that have been registered.
   */
  parse(argv) {
    if (Object.keys(this.commands).length === 0) {
      throw new CLIError.CLIError('COMMAND_NONE_REGISTERED');
    }
    if (this.standAlone) {
      return args.parse(argv, this.getCommand(this.standAlone).getParserOptions());
    }
    try {
      return args.parseInContext(argv, arg => this.getCommand(arg)?.getParserOptions());
    } catch {
      const possibleCmd = argv.find(arg => !arg.startsWith('-')) ?? '';
      this.onCommandNotFound.emit([argv, possibleCmd]);
      if (possibleCmd) {
        const closestCmd = levenary__default.default(possibleCmd, this.getCommandPaths());
        throw new CLIError.CLIError('COMMAND_UNKNOWN', [possibleCmd, closestCmd]);
      }
      throw new CLIError.CLIError('COMMAND_INVALID_RUN');
    }
  }

  /**
   * Render a React element with Ink and output to the configured streams.
   */
  async renderElement(element) {
    // Do not allow nested renders
    // istanbul ignore next
    if (this.rendering) {
      throw new CLIError.CLIError('REACT_RENDER_NO_NESTED');
    } else {
      this.rendering = true;
    }
    const _await$import = await import('ink'),
      render = _await$import.render;
    const _await$import2 = await import('react'),
      createElement = _await$import2.createElement;
    const _this$streams = this.streams,
      stdin = _this$streams.stdin,
      stdout = _this$streams.stdout,
      stderr = _this$streams.stderr;
    const unpatchDebug = patchDebugModule.patchDebugModule();
    try {
      this.onBeforeRender.emit([element]);
      const output = await render(createElement(Wrapper.Wrapper, {
        children: element,
        errBuffer: this.errBuffer,
        exit: this.exit,
        log: this.logger,
        outBuffer: this.outBuffer,
        program: this.options
      }, element), {
        debug: process.env.NODE_ENV === 'test',
        exitOnCtrlC: true,
        experimental: true,
        patchConsole: true,
        stderr,
        stdin,
        stdout
      });

      // This never resolves while testing
      // istanbul ignore next
      if (!internal.env('CLI_TEST_ONLY')) {
        await output.waitUntilExit();
      }
      this.onAfterRender.emit([]);
    } catch (error) {
      // Never runs while testing
      // istanbul ignore next
      this.exit(error);
    } finally {
      this.rendering = false;
      unpatchDebug();
    }
  }

  /**
   * Run the program in the following steps:
   * - Apply middleware to argv list.
   * - Parse argv into an args object (of options, params, etc).
   * - Determine command to run, or fail.
   * - Run command and render output.
   * - Return exit code.
   */
  async run(argv, bootstrap, rethrow = false) {
    this.onBeforeRun.emit([argv]);
    let exitCode = 0;
    try {
      if (bootstrap) {
        await bootstrap();
      }
      exitCode = await this.runAndRender(argv);
      this.onAfterRun.emit([]);
    } catch (error) {
      if (error instanceof Error) {
        exitCode = await this.renderErrors([error]);
        this.onAfterRun.emit([error]);
        if (rethrow) {
          throw error;
        }
      }
    }
    return exitCode;
  }

  /**
   * Run the program and also set the process exit code.
   */
  // istanbul ignore next
  async runAndExit(argv, bootstrap) {
    const exitCode = await this.run(argv, bootstrap);
    process.exitCode = exitCode;
    return exitCode;
  }

  /**
   * Render the index screen when no args are passed.
   * Should include banner, header, footer, and command (if applicable).
   */
  async createIndex() {
    const _await$import3 = await import('react'),
      createElement = _await$import3.createElement;
    if (this.standAlone) {
      return createElement(IndexHelp.IndexHelp, this.options, await this.getCommand(this.standAlone).createHelp());
    }
    const commands = {};

    // Remove sub-commands
    Object.entries(this.commands).forEach(([path, command]) => {
      if (!path.includes(':')) {
        commands[path] = command;
      }
    });
    return createElement(IndexHelp.IndexHelp, this.options, createElement(Help.Help, {
      categories: this.sharedCategories,
      commands: mapCommandMetadata.mapCommandMetadata(commands),
      delimiter: this.options.delimiter,
      header: translate.msg('cli:labelAbout')
    }));
  }

  /**
   * Loop through all middleware to modify the argv list
   * and resulting args object.
   */
  applyMiddlewareAndParseArgs(argv) {
    let index = -1;
    const next = nextArgv => {
      index += 1;
      const middleware = this.middlewares[index];

      // Keep calling middleware until we exhaust them all
      if (middleware) {
        return middleware(nextArgv, next, this.logger);
      }

      // Otherwise all middleware have ran, so parse the final list
      this.commandLine = nextArgv.join(' ');
      return this.parse(nextArgv);
    };
    return next(argv);
  }

  /**
   * Render the result of a command's run to the defined stream.
   * If a string has been returned, write it immediately.
   * If a React component, render with Ink and wait for it to finish.
   */
  async render(result, exitCode = constants.EXIT_PASS) {
    // For simple strings, ignore react and the buffer
    if (typeof result === 'string') {
      this.streams.stdout.write(`${result}\n`);
      return exitCode;
    }
    if (result) {
      await this.renderElement(result);
    }
    return exitCode;
  }

  /**
   * Render an error and warnings menu based on the list provided.
   * If argument parser or validation errors are found, treat them with special logic.
   */
  async renderErrors(errors) {
    const exitError = errors[0];
    if (exitError instanceof common.ExitError && exitError.code === 0) {
      return exitError.code;
    }

    // eslint-disable-next-line unicorn/prefer-array-find
    const parseErrors = errors.filter(error => error instanceof args.ParseError);
    const validErrors = errors.filter(error => error instanceof args.ValidationError);
    const error = parseErrors[0] ?? validErrors[0] ?? exitError;

    // Mostly for testing, but useful for other things
    // istanbul ignore next
    if (internal.env('CLI_TEST_FAIL_HARD')) {
      throw error;
    }
    const _await$import4 = await import('react'),
      createElement = _await$import4.createElement;
    return this.render(createElement(Failure.Failure, {
      binName: this.options.bin,
      commandLine: this.commandLine,
      delimiter: this.options.delimiter,
      error,
      warnings: validErrors.filter(verror => verror !== error)
    }), error instanceof common.ExitError ? error.code : constants.EXIT_FAIL);
  }

  /**
   * Internal run that does all the heavy lifting and parsing,
   * while the public run exists to catch any unexpected errors.
   */
  async runAndRender(argv) {
    const showVersion = argv.some(arg => arg === '-v' || arg === '--version');
    const showHelp = argv.some(arg => arg === '-h' || arg === '--help');

    // Display index help
    if (isArgvSize.isArgvSize(argv, 0) && !this.standAlone || isArgvSize.isArgvSize(argv, 1) && showHelp) {
      this.onHelp.emit([]);
      return this.render(await this.createIndex());
    }

    // Display version
    if (showVersion) {
      return this.render(this.options.version);
    }

    // Parse the arguments
    const _await$this$applyMidd = await this.applyMiddlewareAndParseArgs(argv),
      paths = _await$this$applyMidd.command,
      errors = _await$this$applyMidd.errors,
      options = _await$this$applyMidd.options,
      params = _await$this$applyMidd.params,
      rest = _await$this$applyMidd.rest,
      unknown = _await$this$applyMidd.unknown;
    const path = paths.join(':') || this.standAlone;
    const command = this.getCommand(path);
    this.onCommandFound.emit([argv, path, command]);

    // Apply shared categories to command constructor
    Object.assign(getConstructor.getConstructor(command).categories, this.sharedCategories);

    // Display command help
    if (options.help) {
      this.onHelp.emit([path]);
      return this.render(await command.createHelp());
    }

    // Display errors
    if (errors.length > 0) {
      return this.renderErrors(errors);
    }

    // Apply options to command properties
    Object.assign(command, options);

    // Apply remaining arguments and properties
    command.rest = rest;
    command.unknown = unknown;
    command.exit = this.exit;
    command.log = this.logger;
    command[constants.INTERNAL_OPTIONS] = options;
    command[constants.INTERNAL_PARAMS] = params;
    command[constants.INTERNAL_PROGRAM] = this;
    return this.render(await command.run(...params));
  }
}
exports.Program = Program;
//# sourceMappingURL=Program.cjs.map
