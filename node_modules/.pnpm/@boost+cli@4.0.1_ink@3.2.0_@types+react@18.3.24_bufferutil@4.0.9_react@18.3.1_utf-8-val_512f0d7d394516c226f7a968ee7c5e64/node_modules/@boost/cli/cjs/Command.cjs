'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.cjs');
const execa = require('execa');
const common = require('@boost/common');
const CLIError = require('./CLIError.cjs');
const CommandManager = require('./CommandManager.cjs');
const constants = require('./constants.cjs');
const mapCommandMetadata = require('./helpers/mapCommandMetadata.cjs');
const getConstructor = require('./metadata/getConstructor.cjs');
const getInheritedCategories = require('./metadata/getInheritedCategories.cjs');
const getInheritedOptions = require('./metadata/getInheritedOptions.cjs');
const globalOptions = require('./metadata/globalOptions.cjs');
const validateConfig = require('./metadata/validateConfig.cjs');
const validateOptions = require('./metadata/validateOptions.cjs');
const validateParams = require('./metadata/validateParams.cjs');
require('./react.cjs');
const Help = require('./components/Help.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const execa__default = /*#__PURE__*/_interopDefault(execa);
var _dec, _class, _class2;
let Command = (_dec = common.Memoize(), (_class = (_class2 = class Command extends CommandManager.CommandManager {
  constructor(options) {
    super(options);
    // Args
    /** Value of `--help`, `-h` passed on the command line. */
    this.help = false;
    /** Value of `--locale` passed on the command line. */
    this.locale = 'en';
    /** Additional arguments passed after `--` on the command line. */
    this.rest = [];
    /** Unknown options passed on the command line. */
    this.unknown = {};
    /** Value of `--version`, `-v` passed on the command line. */
    this.version = false;
    // Methods
    /** Method to exit the current program, with an optional error code. */
    this.exit = void 0;
    /** Method to log to the console using a log level. */
    this.log = void 0;
    // Internals
    /** @internal */
    this[constants.INTERNAL_OPTIONS] = void 0;
    /** @internal */
    this[constants.INTERNAL_PARAMS] = void 0;
    /** @internal */
    this[constants.INTERNAL_PROGRAM] = void 0;
    /**
     * Run the program within itself, by passing a custom command and argv list.
     */
    this.runProgram = argv => this.getProgram().run(argv, undefined, true);
    /**
     * Run a task (function) with the defined arguments and
     * the current command instance bound to the task's context.
     */
    this.runTask = (task, ...args) => {
      // We dont want tasks to have full access to the command
      // and its methods, so recreate a similar but smaller context.
      const context = _objectSpread(_objectSpread({
        exit: this.exit,
        log: this.log,
        rest: this.rest,
        unknown: this.unknown
      }, this[constants.INTERNAL_OPTIONS]), {}, {
        runProgram: this.runProgram,
        runTask: this.runTask
      });
      return task.apply(context, args);
    };
    /**
     * Verify sub-command is prefixed with the correct path.
     */
    this.handleBeforeRegister = subPath => {
      const path = this.getPath();
      if (!subPath.startsWith(path)) {
        throw new CLIError.CLIError('COMMAND_INVALID_SUBPATH', [subPath, path]);
      }
    };
    this.onBeforeRegister.listen(this.handleBeforeRegister);
  }

  /**
   * Validate options passed to the constructor.
   */
  // Empty blueprint so that sub-classes may type correctly
  blueprint(schemas) {
    return {};
  }

  /**
   * Create a React element based on the Help component.
   */
  async createHelp() {
    const metadata = this.getMetadata();
    const _await$import = await import('react'),
      createElement = _await$import.createElement;
    return createElement(Help.Help, {
      categories: metadata.categories,
      commands: mapCommandMetadata.mapCommandMetadata(metadata.commands),
      config: metadata,
      delimiter: this[constants.INTERNAL_PROGRAM]?.options.delimiter,
      header: metadata.path,
      options: metadata.options,
      params: metadata.params
    });
  }

  /**
   * Execute a system native command with the given arguments
   * and pass the results through a promise. This does *not* execute Boost CLI
   * commands, use `runProgram()` instead.
   */
  async executeCommand(command, args, options = {}) /* infer */{
    const _this$getProgram = this.getProgram(),
      streams = _this$getProgram.streams;
    return execa__default.default(command, args, _objectSpread(_objectSpread({}, streams), options));
  }

  /**
   * Return the current command class as an arguments object.
   * Options and params must be parsed first to operate correctly.
   */
  getArguments() {
    return {
      command: this.getPath().split(':'),
      errors: [],
      options: this[constants.INTERNAL_OPTIONS] ?? {},
      params: this[constants.INTERNAL_PARAMS] ?? [],
      rest: this.rest,
      unknown: this.unknown
    };
  }

  /**
   * Validate and return all metadata registered to this command instance.
   */
  getMetadata() {
    this.initializeAndValidate();
    const ctor = getConstructor.getConstructor(this);
    const options = {};

    // Since default values for options are represented as class properties,
    // we need to inject the defaults into the argument parsing layer.
    // We can easily do this here and avoid a lot of headache.
    Object.entries(getInheritedOptions.getInheritedOptions(this)).forEach(([option, config]) => {
      options[option] = _objectSpread(_objectSpread({}, config), {}, {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        default: this[option] ?? config.default
      });
    });
    return {
      aliases: ctor.aliases,
      allowUnknownOptions: ctor.allowUnknownOptions,
      allowVariadicParams: ctor.allowVariadicParams,
      categories: getInheritedCategories.getInheritedCategories(this),
      category: ctor.category,
      commands: this.commands,
      deprecated: ctor.deprecated,
      description: ctor.description,
      hidden: ctor.hidden,
      options,
      params: ctor.params,
      path: ctor.path,
      usage: ctor.usage
    };
  }

  /**
   * Return metadata as options for argument parsing.
   */
  getParserOptions() {
    const _this$getMetadata = this.getMetadata(),
      aliases = _this$getMetadata.aliases,
      allowUnknownOptions = _this$getMetadata.allowUnknownOptions,
      allowVariadicParams = _this$getMetadata.allowVariadicParams,
      options = _this$getMetadata.options,
      params = _this$getMetadata.params,
      path = _this$getMetadata.path;
    return {
      commands: [path, ...aliases],
      options,
      params,
      unknown: allowUnknownOptions,
      variadic: Boolean(allowVariadicParams)
    };
  }

  /**
   * Return the command path (canonical name on the command line).
   */
  getPath() {
    return getConstructor.getConstructor(this).path;
  }

  /**
   * Render a React element with Ink and output to the configured streams.
   */
  async render(element) {
    return this.getProgram().renderElement(element);
  }
  /**
   * Loop through class properties and register any options/params that are using
   * the initializer pattern, then validate all the metadata on the command.
   *
   * Note: We memoize so this only runs once!
   */ // eslint-disable-next-line @typescript-eslint/member-ordering
  initializeAndValidate() {
    Object.entries(this).forEach(([prop, value]) => {
      if (common.isObject(value) && value[constants.INTERNAL_INITIALIZER]) {
        value.register(this, prop);

        // @ts-expect-error Allow this hack!
        this[prop] = value.value;
      }
    });
    const ctor = getConstructor.getConstructor(this);
    validateConfig.validateConfig(this.constructor.name, {
      aliases: ctor.aliases,
      allowUnknownOptions: ctor.allowUnknownOptions,
      allowVariadicParams: ctor.allowVariadicParams,
      categories: ctor.categories,
      category: ctor.category,
      deprecated: ctor.deprecated,
      description: ctor.description,
      hidden: ctor.hidden,
      path: ctor.path,
      usage: ctor.usage
    });
    validateOptions.validateOptions(ctor.options);
    validateParams.validateParams(ctor.params);
  }

  /**
   * Return the program instance or fail.
   */
  getProgram() {
    const program = this[constants.INTERNAL_PROGRAM];
    if (!program) {
      throw new CLIError.CLIError('COMMAND_NO_PROGRAM');
    }
    return program;
  }
  /**
   * Executed when the command is being ran.
   */
}, _class2.aliases = [], _class2.allowUnknownOptions = false, _class2.allowVariadicParams = false, _class2.categories = {}, _class2.category = '', _class2.description = '', _class2.deprecated = false, _class2.hidden = false, _class2.options = globalOptions.globalOptions, _class2.params = [], _class2.path = '', _class2.usage = '', _class2), _rollupPluginBabelHelpers.applyDecoratedDescriptor(_class.prototype, "initializeAndValidate", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "initializeAndValidate"), _class.prototype), _class));
exports.Command = Command;
//# sourceMappingURL=Command.cjs.map
