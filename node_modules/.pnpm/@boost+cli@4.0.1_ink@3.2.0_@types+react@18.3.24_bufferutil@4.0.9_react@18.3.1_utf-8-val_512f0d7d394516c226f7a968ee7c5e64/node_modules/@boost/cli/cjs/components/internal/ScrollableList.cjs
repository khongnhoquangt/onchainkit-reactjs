'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const React = require('react');
const ink = require('ink');
require('../../hooks/index.cjs');
const translate = require('../../translate.cjs');
const Style = require('../Style.cjs');
const useDimensions = require('../../hooks/useDimensions.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const React__default = /*#__PURE__*/_interopDefault(React);
function calculateIndexes(maxIndex, currentIndex, limit, scrollType) {
  let startIndex = 0;
  let endIndex = 0;
  switch (scrollType) {
    // Current index is placed at the top, while navigation
    // always displays up to the maximum limit, and wraps around edges.
    case 'cycle':
      startIndex = Math.min(Math.max(currentIndex, 0), maxIndex);
      endIndex = startIndex + limit - 1;
      if (endIndex > maxIndex) {
        endIndex = (endIndex - maxIndex - 1) * -1;
      }
      break;

    // Current index is placed within the middle of the limit,
    // while navigation caps at either edge.
    default:
      {
        const beforeLimit = Math.floor(limit / 2);
        const afterLimit = Math.floor(limit / 2) - (limit % 2 === 0 ? 1 : 0);
        if (currentIndex <= beforeLimit) {
          startIndex = 0;
          endIndex = limit - 1;
        } else if (currentIndex > maxIndex - afterLimit) {
          startIndex = maxIndex - limit + 1;
          endIndex = maxIndex;
        } else {
          startIndex = currentIndex - beforeLimit;
          endIndex = currentIndex + afterLimit;
        }
        break;
      }
  }
  return {
    endIndex,
    startIndex
  };
}
function truncateList(items, startIndex, endIndex) {
  let list;
  let leading = [];
  let trailing = [];

  // Wraps past the end
  if (endIndex <= 0) {
    list = [...items.slice(startIndex), ...items.slice(0, Math.abs(endIndex) + 1)];
    trailing = items.slice(Math.abs(endIndex) + 1, startIndex);

    // Wraps past the beginning
  } else if (startIndex < 0) {
    list = [...items.slice(Math.abs(startIndex)), ...items.slice(0, endIndex + 1)];
    trailing = items.slice(endIndex + 1, Math.abs(startIndex));

    // In the middle
  } else {
    list = items.slice(startIndex, endIndex + 1);
    leading = items.slice(0, startIndex);
    trailing = items.slice(endIndex + 1);
  }
  return {
    leading,
    list,
    trailing
  };
}
function countEnabledItems(items) {
  return items.filter(i => {
    if ('disabled' in i) {
      return !i.disabled;
    }
    if ('divider' in i) {
      return !i.divider;
    }
    return true;
  }).length;
}
function renderOverflowLabel(value, count) {
  if (typeof value === 'string') {
    return value;
  }
  if (typeof value === 'function') {
    return value(count);
  }
  return undefined;
}
function ScrollableList({
  currentIndex,
  items,
  limit,
  overflowAfterLabel,
  overflowBeforeLabel,
  renderItem,
  rowHeight = 1,
  scrollType = 'overflow'
}) {
  const _useDimensions$useDim = useDimensions.useDimensions(),
    viewportHeight = _useDimensions$useDim.height;
  const isOverflow = scrollType === 'overflow';

  // We dont want the list to overflow past the terminal size,
  // so cap it to max number of rows that will fit in the viewport
  // eslint-disable-next-line no-magic-numbers
  const padding = isOverflow ? 4 : 2;
  const maxLimit = Math.floor(Math.min(limit ?? viewportHeight, viewportHeight - padding) / rowHeight);

  // Slice the list according to the chosen scroll type
  const _calculateIndexes = calculateIndexes(items.length - 1, currentIndex, maxLimit, scrollType),
    startIndex = _calculateIndexes.startIndex,
    endIndex = _calculateIndexes.endIndex;
  const _React$useMemo = React.useMemo(() => truncateList(items, startIndex, endIndex), [endIndex, items, startIndex]),
    leading = _React$useMemo.leading,
    list = _React$useMemo.list,
    trailing = _React$useMemo.trailing;
  const leadingCount = countEnabledItems(leading);
  const trailingCount = countEnabledItems(trailing);
  return /*#__PURE__*/React__default.default.createElement(ink.Box, {
    flexDirection: "column"
  }, leadingCount > 0 && isOverflow && /*#__PURE__*/React__default.default.createElement(ink.Box, {
    marginLeft: 2
  }, /*#__PURE__*/React__default.default.createElement(Style.Style, {
    type: "muted"
  }, renderOverflowLabel(overflowBeforeLabel, leadingCount) ?? translate.msg('prompt:scrollOverflowBefore', {
    count: leadingCount
  }))), list.map(item => renderItem(item)), trailingCount > 0 && isOverflow && /*#__PURE__*/React__default.default.createElement(ink.Box, {
    marginLeft: 2
  }, /*#__PURE__*/React__default.default.createElement(Style.Style, {
    type: "muted"
  }, renderOverflowLabel(overflowAfterLabel, trailingCount) ?? translate.msg('prompt:scrollOverflowAfter', {
    count: trailingCount
  }))));
}
exports.ScrollableList = ScrollableList;
exports.calculateIndexes = calculateIndexes;
exports.truncateList = truncateList;
//# sourceMappingURL=ScrollableList.cjs.map
