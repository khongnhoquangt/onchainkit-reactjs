'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const ink = require('ink');
const internal = require('@boost/internal');
const test = require('@boost/log/test');
const terminal = require('@boost/terminal');
require('./index.cjs');
const Program = require('./Program.cjs');
const constants = require('./constants.cjs');

/* eslint-disable no-param-reassign, jest/prefer-spy-on */
class MockReadStream {
  constructor() {
    this.isTTY = false;
  }
}
class MockWriteStream {
  constructor(append = false) {
    this.append = false;
    this.columns = 80;
    this.output = void 0;
    this.append = append;
    this.output = '';
  }
  write(string) {
    if (this.append) {
      this.output += string;
    } else {
      this.output = string;
    }
  }
  get() {
    return this.output;
  }
  on() {}
  off() {}
}

/**
 * Returns mocked `stderr`, `stdout`, and `stdin` streams that can be passed to a `Program`.
 * This does not mock all stream functionality, only those required by Boost and Ink.
 *
 * ```ts
 * import { mockStreams } from '@boost/cli/test';
 *
 * const streams = mockStreams();
 * ```
 */
function mockStreams(append) {
  return {
    stderr: new MockWriteStream(append),
    stdin: new MockReadStream(),
    stdout: new MockWriteStream(append)
  };
}

/**
 * Returns a `Program` instance with required options pre-filled and streams mocked
 * (unless manually provided).
 *
 * ```ts
 * import { mockProgram } from '@boost/cli/test';
 *
 * const program = mockProgram({ name: 'Example' });
 * ```
 */
function mockProgram(options, streams) {
  return new Program.Program(_objectSpread({
    bin: 'test',
    name: 'Test',
    version: '0.0.0'
  }, options), streams ?? mockStreams());
}

/**
 * Can be used to render a React component with Ink and return the rendered result
 * as a terminal compatible string. If `stripped` is true, it will strip ANSI
 * escape escape sequences.
 *
 * ```tsx
 * import { renderComponent } from '@boost/cli/test';
 * import TestComponent from '../src/components/TestComponent';
 *
 * it('renders a component', async () => {
 * 	expect(await renderComponent(<TestComponent />)).toMatchSnapshot();
 * });
 * ```
 *
 * > As an alternative, we also suggest using the official
 * > [ink-testing-library](https://github.com/vadimdemedes/ink-testing-library).
 */
async function renderComponent(element, stripped = false) {
  let output = '';
  try {
    const _await$import = await import('ink-testing-library'),
      renderAsTest = _await$import.render;
    const _await$renderAsTest = await renderAsTest(element),
      lastFrame = _await$renderAsTest.lastFrame;
    output = lastFrame() ?? '';
  } catch {
    const stdout = new MockWriteStream();
    await ink.render(element, {
      debug: true,
      experimental: true,
      stdout: stdout
    });
    output = stdout.get();
  }
  return stripped ? terminal.stripAnsi(output) : output;
}

/**
 * Runs a `Command` outside the context of a `Program`, but mimics similar functionality,
 * including React component rendering. Params are required as they're passed to the run method,
 * while options are optional and assume class properties have been defined. Also, the `exit`
 * and `log` methods have been mocked with Jest spies so that they can be asserted.
 *
 * ```ts
 * import { runCommand } from '@boost/cli/test';
 * import TestCommand from '../src/commands/TestCommand';
 *
 * it('runs a command', async () => {
 * 	const command = new TestCommand();
 *
 * 	expect(await runCommand(command, ['foo', 'bar', 'baz'])).toMatchSnapshot();
 * 	expect(command.log).toHaveBeenCalled();
 * });
 * ```
 *
 * > Since there is no `Program` context, any functionality that requires a program will fail. If
 * > needed, use `runProgram()` instead.
 */
async function runCommand(command, params, options) {
  if (options) {
    Object.assign(command, options);

    // @ts-expect-error Allow overwrite
    command[constants.INTERNAL_OPTIONS] = _objectSpread({
      help: false,
      locale: 'en',
      version: false
    }, options);
  }
  command.exit = jest.fn();
  command.log = test.mockLogger();
  command[constants.INTERNAL_PARAMS] = params;
  const result = await command.run(...params);
  if (!result || typeof result === 'string') {
    return result ?? '';
  }
  return renderComponent(result);
}

/**
 * Runs a task function outside the context of a `Command`, in complete isolation.
 * A mock command context is provided with standard defaults, and can be customized
 * through the 3rd argument.
 *
 * ```ts
 * import { runTask } from '@boost/cli/test';
 * import testTask from '../src/tasks/testTask';
 *
 * it('runs a task', async () => {
 * 	const context = {
 * 		log: jest.fn(),
 * 	};
 *
 * 	expect(await runTask(testTask, ['foo', 'bar', 'baz'], context)).toMatchSnapshot();
 * 	expect(context.log).toHaveBeenCalled();
 * });
 * ```
 */
function runTask(task, args, context) {
  const notTestable = name => () => {
    throw new Error(`\`${name}\` is not testable using the \`runTask\` utility. Test using a full program.`);
  };
  const baseContext = {
    exit: jest.fn(),
    help: false,
    locale: 'en',
    log: test.mockLogger(),
    rest: [],
    runProgram: notTestable('runProgram'),
    runTask: notTestable('runTask'),
    unknown: {},
    version: false
  };
  return task.apply(_objectSpread(_objectSpread({}, baseContext), context), args);
}

/**
 * Runs a `Program` as if it were ran on the command line, including middleware,
 * commands, success and failure states, and more. Utilizes mocked streams to capture
 * and return standard output and ANSI stripped output. Failed runs will not throw
 * and instead will render a failure output.
 *
 * ```ts
 * import { runProgram } from '@boost/cli/test';
 * import Program from '../src/program';
 *
 * it('runs a program', async () => {
 * 	const program = new Program();
 *
 * 	const { code, output } = await runProgram(program, ['cmd', '--foo', '123', 'bar']);
 *
 * 	expect(output).toMatchSnapshot();
 * 	expect(code).toBe(0);
 * });
 * ```
 */
async function runProgram(program, argv, options = {}) {
  if (!(program.streams.stderr instanceof MockWriteStream)) {
    program.streams.stderr = new MockWriteStream(options.append);
  }
  if (!(program.streams.stdout instanceof MockWriteStream)) {
    program.streams.stdout = new MockWriteStream(options.append);
  }
  if (!(program.streams.stdin instanceof MockReadStream)) {
    program.streams.stdin = new MockReadStream();
  }

  // Ink async rendering never resolves while testing,
  // as it relies on system signals to "exit".
  // So we set this to flag the renderer to avoid awaiting.
  internal.env('CLI_TEST_ONLY', 'true');
  const code = await program.run(argv);
  internal.env('CLI_TEST_ONLY', null);
  const output = program.streams.stdout.get() + program.streams.stderr.get();
  return {
    code,
    output,
    outputStripped: terminal.stripAnsi(output)
  };
}
exports.MockReadStream = MockReadStream;
exports.MockWriteStream = MockWriteStream;
exports.mockProgram = mockProgram;
exports.mockStreams = mockStreams;
exports.renderComponent = renderComponent;
exports.runCommand = runCommand;
exports.runProgram = runProgram;
exports.runTask = runTask;
//# sourceMappingURL=test.cjs.map
