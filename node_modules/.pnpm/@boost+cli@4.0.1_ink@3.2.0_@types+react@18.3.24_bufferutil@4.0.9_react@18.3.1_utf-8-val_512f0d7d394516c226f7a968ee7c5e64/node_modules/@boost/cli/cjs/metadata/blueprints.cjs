'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const args = require('@boost/args');
const optimal = require('@boost/common/optimal');

/* eslint-disable @typescript-eslint/no-explicit-any */
const _optimal$schemas = optimal.schemas,
  array = _optimal$schemas.array,
  bool = _optimal$schemas.bool,
  func = _optimal$schemas.func,
  number = _optimal$schemas.number,
  object = _optimal$schemas.object,
  shape = _optimal$schemas.shape,
  string = _optimal$schemas.string,
  union = _optimal$schemas.union;
const commonBlueprint = {
  deprecated: bool(),
  description: string().notEmpty().required(),
  hidden: bool()
};

// COMMANDS

const commandConstructorBlueprint = _objectSpread(_objectSpread({}, commonBlueprint), {}, {
  aliases: array().of(string()),
  allowUnknownOptions: bool(),
  allowVariadicParams: union(false).of([bool(), string()]),
  categories: object().of(union('').of([string().notEmpty(), shape({
    name: string().notEmpty(),
    weight: number()
  })])),
  category: string(),
  hasRegisteredOptions: string(),
  path: string().notEmpty().required().match(args.COMMAND_FORMAT),
  usage: union([]).of([string(), array().of(string())])
});

// ARGS

const argBlueprint = _objectSpread(_objectSpread({}, commonBlueprint), {}, {
  default: union('').of([bool(), number(), string()]),
  format: func(),
  type: string('string').required(),
  validate: func()
});

// OPTIONS

const optionBlueprint = _objectSpread(_objectSpread({}, argBlueprint), {}, {
  category: string(),
  short: string().when(
  // @ts-expect-error Ignore types
  value => value !== '', string().match(/^[a-z]$/giu))
});
const flagBlueprint = _objectSpread(_objectSpread({}, optionBlueprint), {}, {
  default: bool(args.DEFAULT_BOOLEAN_VALUE),
  type: string().oneOf(['boolean'])
});
const stringOptionBlueprint = _objectSpread(_objectSpread({}, optionBlueprint), {}, {
  choices: array().of(string()),
  count: bool().never(),
  default: string(args.DEFAULT_STRING_VALUE),
  type: string().oneOf(['string'])
});
const stringsOptionBlueprint = _objectSpread(_objectSpread({}, optionBlueprint), {}, {
  arity: number(),
  default: array().of(string()),
  multiple: bool().onlyTrue(),
  type: string().oneOf(['string'])
});
const numberOptionBlueprint = _objectSpread(_objectSpread({}, optionBlueprint), {}, {
  choices: array().of(number()),
  count: bool().onlyTrue(),
  default: number(args.DEFAULT_NUMBER_VALUE),
  type: string().oneOf(['number'])
});
const numbersOptionBlueprint = _objectSpread(_objectSpread({}, optionBlueprint), {}, {
  arity: number(),
  default: array().of(number()),
  multiple: bool().onlyTrue(),
  type: string().oneOf(['number'])
});

// PARAMS

const paramBlueprint = _objectSpread(_objectSpread({}, argBlueprint), {}, {
  label: string(),
  required: bool(),
  validate: func()
});
exports.argBlueprint = argBlueprint;
exports.commandConstructorBlueprint = commandConstructorBlueprint;
exports.commonBlueprint = commonBlueprint;
exports.flagBlueprint = flagBlueprint;
exports.numberOptionBlueprint = numberOptionBlueprint;
exports.numbersOptionBlueprint = numbersOptionBlueprint;
exports.optionBlueprint = optionBlueprint;
exports.paramBlueprint = paramBlueprint;
exports.stringOptionBlueprint = stringOptionBlueprint;
exports.stringsOptionBlueprint = stringsOptionBlueprint;
//# sourceMappingURL=blueprints.cjs.map
