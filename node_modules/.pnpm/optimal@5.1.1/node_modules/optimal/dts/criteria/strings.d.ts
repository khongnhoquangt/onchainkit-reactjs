import { Criteria, Options, SchemaState, StringContainsOptions } from '../types';
/**
 * Require field value to contain a provided string.
 */
export declare function contains(state: SchemaState<string>, token: string, options?: StringContainsOptions): Criteria<string>;
/**
 * Require field value to match a defined regex pattern.
 */
export declare function match(state: SchemaState<string>, pattern: RegExp, options?: Options): Criteria<string>;
/**
 * Require field value to be formatted in camel case (fooBar).
 */
export declare function camelCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be formatted in kebab case (foo-bar).
 */
export declare function kebabCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be formatted in pascal case (FooBar).
 */
export declare function pascalCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be formatted in snake case (foo_bar).
 */
export declare function snakeCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to not be an empty string.
 */
export declare function notEmpty(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be one of the provided strings.
 */
export declare function oneOf(state: SchemaState<string>, list: string[], options?: Options): Criteria<string>;
/**
 * Require field value to be all lower case.
 */
export declare function lowerCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be all upper case.
 */
export declare function upperCase(state: SchemaState<string>, options?: Options): Criteria<string>;
/**
 * Require field value to be of a specific string length.
 */
export declare function lengthOf(state: SchemaState<string>, size: number, options?: Options): Criteria<string>;
//# sourceMappingURL=strings.d.ts.map