// Bundled with Packemon: https://packemon.dev
// Platform: node, Support: stable, Format: lib
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
const PATH_TOKEN = /"(\[\d+]|\w+)"/i;
const LIST_CHECK = /(\n|\s)+-/;

class ValidationError extends Error {
  /** List of invalidations for the field. */

  /** Object path for the invalid field. */

  /** Field value at time of failure. */

  /** Whether an original message was provided through the constructor. */

  /** Whether a "Invalid path" message was prepended to the original message. */
  constructor(message, path = '', value = undefined) {
    super(typeof message === 'string' ? message : '');

    _defineProperty(this, "errors", []);

    _defineProperty(this, "path", void 0);

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "hasOriginalMessage", false);

    _defineProperty(this, "hasPathPrefix", false);

    this.name = 'ValidationError';
    this.path = path;
    this.value = value;
    this.hasOriginalMessage = this.message !== '';

    if (path) {
      const key = pathKey(path);
      const type = key.includes('[') ? 'member' : 'field';
      this.message = `Invalid ${type} "${key}". ${this.message}`.trim();
      this.hasPathPrefix = true;
    }

    if (Array.isArray(message)) {
      this.addErrors(message);
    }
  }

  addErrors(errors) {
    this.errors = errors.map(error => error instanceof ValidationError ? error : new ValidationError(error.message)); // Inline error if only 1 and...

    const firstError = this.errors[0];

    if (this.errors.length === 1 && (!this.hasOriginalMessage && !firstError.message.match(LIST_CHECK) || this.message === '')) {
      this.message = // Avoid double path prefixes by concatenating them
      this.hasPathPrefix && firstError.hasPathPrefix ? firstError.message.replace(PATH_TOKEN, (match, subPath) => `"${this.path}${subPath.startsWith('[') ? '' : '.'}${subPath}"`) : `${this.message} ${firstError.message}`.trim(); // Bubble this up

      if (firstError.hasPathPrefix) {
        this.hasPathPrefix = true;
      }

      return this;
    } // Otherwise list out all errors


    const indent = this.hasOriginalMessage || this.hasPathPrefix ? '  ' : '';
    const used = new Set();
    this.errors.forEach(error => {
      if (used.has(error.message)) {
        return;
      }

      if (this.message) {
        this.message += '\n';
      }

      this.message += error.message.split('\n').map(line => line.match(/^\s*-/) ? `${indent}${line}` : `${indent}- ${line}`).join('\n');
      used.add(error.message);
    });
    return this;
  }

}

function isObject(value) {
  return !!value && typeof value === 'object' && !Array.isArray(value);
}

function isSchema(value) {
  return isObject(value) && typeof value.schema === 'function' && typeof value.state === 'function' && typeof value.type === 'function' && typeof value.validate === 'function';
}

function isValidDate(value) {
  return Object.prototype.toString.call(value) === '[object Date]' && !Number.isNaN(value.getTime()) && value.toString() !== 'Invalid Date';
}

function isValidNumber(value) {
  return typeof value === 'number' && !Number.isNaN(value);
}

function isValidString(value) {
  return typeof value === 'string' && value !== '';
}

function createArray(value) {
  if (value === undefined) {
    return [];
  }

  return Array.isArray(value) ? [...value] : [value];
}

function createDate(value) {
  if (value instanceof Date) {
    return value;
  }

  if (value === undefined || value === null) {
    return new Date();
  }

  return new Date(value);
}

function createObject(value) {
  return isObject(value) ? _objectSpread({}, value) : {};
}
/**
 * Native `instanceof` checks are problematic, as cross realm checks fail.
 * They will also fail when comparing against source and compiled files.
 * So emulate an `instanceof` check by comparing constructor names.
 */


function instanceOf(object, contract) {
  if (!object || typeof object !== 'object') {
    return false;
  }

  if (object instanceof contract) {
    return true;
  }

  let current = object;

  while (current) {
    if (current.constructor.name === 'Object') {
      return false;
    }

    if (current.constructor.name === contract.name || current instanceof Error && current.name === contract.name) {
      return true;
    } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


    current = Object.getPrototypeOf(current);
  }

  return false;
}

function invalid(condition, message, path = '', value = undefined) {
  if (condition) {
    return;
  }

  throw new ValidationError(String(message), path, value);
}

function invariant(condition, message) {
  if (condition) {
    return;
  }

  throw new Error(message);
}

function logUnknown(unknownFields, pathPrefix) {
  const unknownKeys = Object.keys(unknownFields);

  if (unknownKeys.length > 0) {
    throw new Error(`${pathPrefix ? `Unknown "${pathPrefix}" fields` : 'Unknown fields'}: ${unknownKeys.join(', ')}.`);
  }
}

function pathKey(path) {
  if (path.endsWith(']')) {
    const index = path.lastIndexOf('[');
    return index > 0 ? path.slice(index) : path;
  }

  const index = path.lastIndexOf('.');
  return index > 0 ? path.slice(index + 1) : path;
}

function prettyValue(value) {
  if (value instanceof Date) {
    return value.toLocaleDateString();
  }

  switch (typeof value) {
    case 'string':
      return `"${value}"`;

    case 'number':
    case 'function':
      return String(value);

    case 'object':
      {
        if (value === null) {
          return `\`null\``;
        }

        if (value.constructor !== Object) {
          return value.constructor.name === 'Array' ? null : `\`${value.constructor.name}\``;
        }

        return null;
      }

    default:
      return `\`${value}\``;
  }
}

function extractDefaultValue(defaultValue, path, {
  currentObject,
  rootObject
}) {
  return typeof defaultValue === 'function' ? defaultValue(path, currentObject, rootObject) : defaultValue;
}

function typeOf(value) {
  if (Array.isArray(value)) {
    return 'array/tuple';
  }

  if (isObject(value)) {
    return value.constructor === Object ? 'object/shape' : 'class';
  }

  return typeof value;
}

function validate(state, validators, initialValue, path = '', {
  currentObject = {},
  rootObject = currentObject
} = {}) {
  const defaultValue = state.defaultValue,
        metadata = state.metadata;
  let value = initialValue; // Handle undefined

  if (value === undefined) {
    if (!state.undefinable) {
      value = extractDefaultValue(defaultValue, path, {
        currentObject,
        rootObject
      });
    }
  } else {
    var _metadata$neverMessag;

    if (process.env.NODE_ENV !== "production" && metadata.deprecatedMessage) {
      // eslint-disable-next-line no-console
      console.info(`Field "${path}" is deprecated. ${metadata.deprecatedMessage}`);
    }

    invalid(!state.never, (_metadata$neverMessag = metadata.neverMessage) !== null && _metadata$neverMessag !== void 0 ? _metadata$neverMessag : 'Field should never be used.', path);
  } // Handle null


  if (value === null) {
    var _metadata$nullableMes;

    invalid(state.nullable, (_metadata$nullableMes = metadata.nullableMessage) !== null && _metadata$nullableMes !== void 0 ? _metadata$nullableMes : 'Null is not allowed.', path, null);
  } // Run validations and produce a new value


  validators.forEach(test => {
    if (!test.dontSkipIfNull && state.nullable && value === null || !test.dontSkipIfUndefined && state.undefinable && value === undefined || state.never) {
      return;
    }

    const result = test.validate(value, path, {
      currentObject,
      rootObject
    });

    if (result !== undefined) {
      value = result;
    }
  });
  return value;
}
/**
 * Create a custom schema with a defined list of criteria.
 * When a value is being validated, all chained criteria will be ran
 * to test for failures. If no failures, a type casted value is returned.
 */


function createSchema({
  api,
  cast,
  defaultValue,
  type
}, criteria = []) {
  const state = {
    defaultValue,
    metadata: {},
    never: false,
    nullable: false,
    required: false,
    type,
    undefinable: false
  };
  const validators = [];
  criteria.forEach(crit => {
    if (typeof crit === 'function') {
      const validator = crit(state);

      if (validator) {
        validators.push(validator);
      }
    } else {
      validators.push(crit);
    }
  });
  const schema = {
    schema() {
      return type;
    },

    state() {
      return state;
    },

    type() {
      return state.type;
    },

    // @ts-expect-error Ignore null/undefined
    validate(value, path, options) {
      const result = validate(state, validators, value, path, options);

      if (state.nullable && result === null) {
        return null;
      }

      if (state.undefinable && result === undefined) {
        return undefined;
      }

      return cast ? cast(result) : result;
    }

  };
  Object.entries(api).forEach(([name, method]) => {
    Object.defineProperty(schema, name, {
      enumerable: true,
      // Create a new schema so that our chainable API is immutable
      value: (...args) => createSchema({
        api,
        cast,
        defaultValue,
        type
      }, [...criteria, nextState => method(nextState, ...args)])
    });
  });
  return schema;
}
/**
 * Require field array to not be empty.
 */


function notEmpty$2(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message;

      invalid(value.length > 0, (_options$message = options.message) !== null && _options$message !== void 0 ? _options$message : 'Array cannot be empty.', path, value);
    }

  };
}
/**
 * Require field array items to be of a specific schema type.
 * Will rebuild the array and type cast values.
 */


function of$5(state, itemsSchema) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isSchema(itemsSchema), 'A schema is required for array items.');
  }

  state.type += `<${itemsSchema.type()}>`;
  return {
    validate(value, path, validateOptions) {
      if (!Array.isArray(value)) {
        return [];
      }

      const nextValue = [...value];
      value.forEach((item, i) => {
        nextValue[i] = itemsSchema.validate(item, `${path}[${i}]`, validateOptions);
      });
      return nextValue;
    }

  };
}
/**
 * Require field array to be of a specific size.
 */


function sizeOf$1(state, size, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof size === 'number' && size > 0, 'Size of requires a non-zero positive number.');
  }

  return {
    validate(value, path) {
      var _options$message2;

      invalid(value.length === size, (_options$message2 = options.message) !== null && _options$message2 !== void 0 ? _options$message2 : `Array length must be ${size}, received ${value.length}.`, path, value);
    }

  };
}

const arrayCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  notEmpty: notEmpty$2,
  of: of$5,
  sizeOf: sizeOf$1
});
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */

/**
 * Require this field to only be `false`.
 */

function onlyFalse(state, options = {}) {
  state.defaultValue = false;
  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path) {
      var _options$message3;

      invalid(value === false, (_options$message3 = options.message) !== null && _options$message3 !== void 0 ? _options$message3 : 'May only be `false`.', path, value);
    }

  };
}
/**
 * Require this field to only be `true`.
 */


function onlyTrue(state, options = {}) {
  state.defaultValue = true;
  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path) {
      var _options$message4;

      invalid(value === true, (_options$message4 = options.message) !== null && _options$message4 !== void 0 ? _options$message4 : 'May only be `true`.', path, value);
    }

  };
}

const booleanCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  onlyFalse: onlyFalse,
  onlyTrue: onlyTrue
});
/**
 * Require this field to be an instance of the defined class.
 * When `loose` is true, will compare using the class name.
 * This should only be used when dealing with realms and package hazards.
 */

function of$4(state, ref, options = {}) {
  var _ref$name;

  if (process.env.NODE_ENV !== "production") {
    invariant(typeof ref === 'function', 'A class reference is required.');
  }

  state.type = (_ref$name = ref.name) !== null && _ref$name !== void 0 ? _ref$name : ref.constructor.name;
  return {
    validate(value, path) {
      var _options$message5;

      invalid(typeof ref === 'function' && (value instanceof ref || !!options.loose && isObject(value) && instanceOf(value, ref)), (_options$message5 = options.message) !== null && _options$message5 !== void 0 ? _options$message5 : `Must be an instance of \`${state.type}\`.`, path, value);
    }

  };
}

const classCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  of: of$4
});

class OptimalError extends ValidationError {
  /** File name/path that is being validated. */

  /** Unique name for this validation. */
  constructor(errors, options) {
    super('The following validations have failed:');

    _defineProperty(this, "file", '');

    _defineProperty(this, "schema", '');

    this.name = 'OptimalError';
    let label = '';

    if (options.name) {
      this.schema = options.name;
      label = `\`${options.name}\``;
    }

    if (options.file) {
      this.file = options.file;
      label = label ? `${label} (${options.file})` : `\`${options.file}\``;
    }

    if (label) {
      this.message = `The following validations have failed for ${label}:`;
    }

    this.addErrors(errors);
  }

}
/**
 * Map a list of field names that must be defined alongside this field when in a shape/object.
 */


function and(state, keys, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(keys.length > 0, 'AND requires a list of field names.');
  }

  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path, {
      currentObject
    }) {
      var _options$message6;

      const andKeys = [...new Set([pathKey(path), ...keys])].sort();
      const undefs = andKeys.filter(key => (currentObject === null || currentObject === void 0 ? void 0 : currentObject[key]) == null); // Only error once when one of the struct is defined

      if (undefs.length === andKeys.length) {
        return;
      }

      invalid(undefs.length === 0, (_options$message6 = options.message) !== null && _options$message6 !== void 0 ? _options$message6 : `All of these fields must be defined: ${andKeys.join(', ')}`);
    }

  };
}
/**
 * Set a callback to run custom validation logic.
 */


function custom$1(state, validator) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof validator === 'function', 'Custom requires a validation function.');
  }

  return {
    validate(value, path, validateOptions) {
      try {
        validator(value, path, validateOptions);
      } catch (error) {
        if (error instanceof ValidationError || error instanceof OptimalError) {
          throw error;
        } else if (error instanceof Error) {
          invalid(false, error.message, path, value);
        }
      }
    }

  };
}
/**
 * Set a message to log when this field is present.
 */


function deprecate(state, message) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isValidString(message), 'A non-empty string is required for deprecated messages.');
  }

  state.metadata.deprecatedMessage = message;
}
/**
 * Mark that this field should never be used.
 */


function never(state, options = {}) {
  state.metadata.neverMessage = options.message;
  state.defaultValue = undefined;
  state.never = true;
}
/**
 * Require this field to be explicitly defined when in a shape/object.
 */


function required(state, options = {}) {
  state.metadata.requiredMessage = options.message;
  state.required = true;
}
/**
 * Dont require this field to be explicitly defined when in a shape/object.
 */


function optional(state) {
  state.required = false;
}
/**
 * Disallow null values.
 */


function notNullable(state, options = {}) {
  state.metadata.nullableMessage = options.message;
  state.nullable = false;
}
/**
 * Allow null values.
 */


function nullable(state) {
  state.nullable = true;
}
/**
 * Mark that this field can ONLY use a value that matches the default value.
 */


function only(state, options = {}) {
  const defaultValue = state.defaultValue;

  if (process.env.NODE_ENV !== "production") {
    invariant(defaultValue !== null && defaultValue !== undefined, 'Only requires a non-empty default value.');
  }

  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path, validateOptions) {
      var _options$message7;

      const testValue = extractDefaultValue(defaultValue, path, validateOptions);
      invalid(value === testValue, (_options$message7 = options.message) !== null && _options$message7 !== void 0 ? _options$message7 : `Value may only be "${testValue}".`, path, value);
    }

  };
}
/**
 * Map a list of field names that must have at least 1 defined when in a shape/object.
 */


function or(state, keys, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(keys.length > 0, 'OR requires a list of field names.');
  }

  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path, {
      currentObject
    }) {
      var _options$message8;

      const orKeys = [...new Set([pathKey(path), ...keys])].sort();
      const defs = orKeys.filter(key => (currentObject === null || currentObject === void 0 ? void 0 : currentObject[key]) !== undefined && (currentObject === null || currentObject === void 0 ? void 0 : currentObject[key]) !== null);
      invalid(defs.length > 0, (_options$message8 = options.message) !== null && _options$message8 !== void 0 ? _options$message8 : `At least one of these fields must be defined: ${orKeys.join(', ')}`);
    }

  };
}
/**
 * Allow undefined values.
 */


function undefinable(state) {
  state.undefinable = true;
}
/**
 * Disallow undefined values.
 */


function notUndefinable(state) {
  state.undefinable = false;
}
/**
 * Transform a value before it's passed to the next criteria.
 */


function transform(state, transformer) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof transformer === 'function', 'A function is required for transforming values.');
  }

  return {
    validate(value, path) {
      const beforeType = typeOf(value);
      const nextValue = transformer(value);
      const afterType = typeOf(nextValue);
      invalid(afterType === beforeType, `Invalid transformed value, expected ${beforeType} but received ${afterType}.`, path, value);
      return nextValue;
    }

  };
}
/**
 * Validate with another schema when a condition is met.
 */


function when(state, condition, pass, fail) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isSchema(pass), 'A schema is required when the condition passes.');
  }

  if (fail !== undefined) {
    if (process.env.NODE_ENV !== "production") {
      invariant(isSchema(fail), 'A schema is required when the condition fails.');
    }
  }

  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path, validateOptions) {
      const passed = typeof condition === 'function' ? condition(value, validateOptions.currentObject, validateOptions.rootObject) : condition === value;

      if (passed) {
        return pass.validate(value, path, validateOptions);
      }

      if (fail) {
        return fail.validate(value, path, validateOptions);
      }

      return undefined;
    }

  };
}
/**
 * Map a list of field names that must not be defined alongside this field when in a shape/object.
 */


function xor(state, keys, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(keys.length > 0, 'XOR requires a list of field names.');
  }

  return {
    dontSkipIfNull: true,
    dontSkipIfUndefined: true,

    validate(value, path, {
      currentObject
    }) {
      var _options$message9;

      const xorKeys = [...new Set([pathKey(path), ...keys])].sort();
      const defs = xorKeys.filter(key => (currentObject === null || currentObject === void 0 ? void 0 : currentObject[key]) !== undefined && (currentObject === null || currentObject === void 0 ? void 0 : currentObject[key]) !== null);
      invalid(defs.length === 1, (_options$message9 = options.message) !== null && _options$message9 !== void 0 ? _options$message9 : `Only one of these fields may be defined: ${xorKeys.join(', ')}`);
    }

  };
}

const commonCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  and: and,
  custom: custom$1,
  deprecate: deprecate,
  never: never,
  required: required,
  optional: optional,
  notNullable: notNullable,
  nullable: nullable,
  only: only,
  or: or,
  undefinable: undefinable,
  notUndefinable: notUndefinable,
  transform: transform,
  when: when,
  xor: xor
});
/**
 * Require field value to be after the provided date.
 */

function after(state, date, options = {}) {
  const afterDate = createDate(date);

  if (process.env.NODE_ENV !== "production") {
    invariant(isValidDate(afterDate), 'After date must be a valid date.');
  }

  return {
    validate(value, path) {
      var _options$message10;

      invalid(isValidDate(value) && value > afterDate, (_options$message10 = options.message) !== null && _options$message10 !== void 0 ? _options$message10 : `Date must come after ${prettyValue(afterDate)}, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be before the provided date.
 */


function before(state, date, options = {}) {
  const beforeDate = createDate(date);

  if (process.env.NODE_ENV !== "production") {
    invariant(isValidDate(beforeDate), 'Before date must be a valid date.');
  }

  return {
    validate(value, path) {
      var _options$message11;

      invalid(isValidDate(value) && value < beforeDate, (_options$message11 = options.message) !== null && _options$message11 !== void 0 ? _options$message11 : `Date must come before ${prettyValue(beforeDate)}, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be between 2 date ranges.
 */


function between$1(state, start, end, options = {}) {
  const startDate = createDate(start);
  const endDate = createDate(end);

  if (process.env.NODE_ENV !== "production") {
    invariant(isValidDate(startDate), 'Between start date must be a valid date.');
  }

  if (process.env.NODE_ENV !== "production") {
    invariant(isValidDate(endDate), 'Between end date must be a valid date.');
  }

  return {
    validate(value, path) {
      var _options$message12;

      invalid(isValidDate(value) && (options.inclusive ? value >= startDate && value <= endDate : value > startDate && value < endDate), (_options$message12 = options.message) !== null && _options$message12 !== void 0 ? _options$message12 : `Date must be between ${prettyValue(startDate)} and ${prettyValue(endDate)}${options.inclusive ? ' inclusive' : ''}, received ${prettyValue(value)}.`, path, value);
    }

  };
}

const dateCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  after: after,
  before: before,
  between: between$1
});
/**
 * Require field value to be between 2 numbers.
 */

function between(state, min, max, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isValidNumber(min) && isValidNumber(max), 'Between requires a minimum and maximum number.');
  }

  return {
    validate(value, path) {
      var _options$message13;

      invalid(isValidNumber(value) && (options.inclusive ? value >= min && value <= max : value > min && value < max), (_options$message13 = options.message) !== null && _options$message13 !== void 0 ? _options$message13 : `Number must be between ${min} and ${max}${options.inclusive ? ' inclusive' : ''}, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be a float (requires a decimal).
 */


function float(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message14;

      invalid(isValidNumber(value) && value % 1 !== 0, (_options$message14 = options.message) !== null && _options$message14 !== void 0 ? _options$message14 : `Number must be a float, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be greater than a number.
 */


function gt(state, min, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isValidNumber(min), 'Greater-than requires a minimum number.');
  }

  return {
    validate(value, path) {
      if (options.inclusive) {
        var _options$message15;

        invalid(isValidNumber(value) && value >= min, (_options$message15 = options.message) !== null && _options$message15 !== void 0 ? _options$message15 : `Number must be greater than or equal to ${min}, received ${prettyValue(value)}.`, path, value);
      } else {
        var _options$message16;

        invalid(isValidNumber(value) && value > min, (_options$message16 = options.message) !== null && _options$message16 !== void 0 ? _options$message16 : `Number must be greater than ${min}, received ${prettyValue(value)}.`, path, value);
      }
    }

  };
}
/**
 * Require field value to be greater than or equals to a number.
 */


function gte(state, min, options = {}) {
  return gt(state, min, _objectSpread(_objectSpread({}, options), {}, {
    inclusive: true
  }));
}
/**
 * Require field value to be an integer.
 */


function int(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message17;

      invalid(Number.isSafeInteger(value), (_options$message17 = options.message) !== null && _options$message17 !== void 0 ? _options$message17 : `Number must be an integer, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be less than a number.
 */


function lt(state, max, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isValidNumber(max), 'Less-than requires a maximum number.');
  }

  return {
    validate(value, path) {
      if (options.inclusive) {
        var _options$message18;

        invalid(isValidNumber(value) && value <= max, (_options$message18 = options.message) !== null && _options$message18 !== void 0 ? _options$message18 : `Number must be less than or equal to ${max}, received ${prettyValue(value)}.`, path, value);
      } else {
        var _options$message19;

        invalid(isValidNumber(value) && value < max, (_options$message19 = options.message) !== null && _options$message19 !== void 0 ? _options$message19 : `Number must be less than ${max}, received ${prettyValue(value)}.`, path, value);
      }
    }

  };
}
/**
 * Require field value to be less than or equals to a number.
 */


function lte(state, max, options = {}) {
  return lt(state, max, _objectSpread(_objectSpread({}, options), {}, {
    inclusive: true
  }));
}
/**
 * Require field value to be negative and _not_ zero.
 */


function negative(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message20;

      invalid(isValidNumber(value) && value < 0, (_options$message20 = options.message) !== null && _options$message20 !== void 0 ? _options$message20 : `Number must be negative, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be one of the provided numbers.
 */


function oneOf$1(state, list, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(Array.isArray(list) && list.length > 0 && list.every(item => isValidNumber(item)), 'One of requires an array of numbers.');
  }

  return {
    validate(value, path) {
      var _options$message21;

      invalid(list.includes(value), (_options$message21 = options.message) !== null && _options$message21 !== void 0 ? _options$message21 : `Number must be one of: ${list.join(', ')}. Received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be positive and _not_ zero.
 */


function positive(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message22;

      invalid(isValidNumber(value) && value > 0, (_options$message22 = options.message) !== null && _options$message22 !== void 0 ? _options$message22 : `Number must be positive, received ${prettyValue(value)}.`, path, value);
    }

  };
}

const numberCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  between: between,
  float: float,
  gt: gt,
  gte: gte,
  int: int,
  lt: lt,
  lte: lte,
  negative: negative,
  oneOf: oneOf$1,
  positive: positive
});
/**
 * Require field object keys to be of a string schema type.
 */

function keysOf(state, keysSchema, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isSchema(keysSchema) && keysSchema.schema() === 'string', 'A string schema is required for object keys.');
  }

  return {
    validate(value, path, validateOptions) {
      if (isObject(value)) {
        Object.keys(value).forEach(key => {
          try {
            // Dont pass path so its not included in the error message
            keysSchema.validate(key, '', validateOptions);
          } catch (error) {
            if (error instanceof Error) {
              var _options$message23;

              invalid(false, `Invalid key "${key}". ${(_options$message23 = options.message) !== null && _options$message23 !== void 0 ? _options$message23 : error.message}`, path, value);
            }
          }
        });
      }
    }

  };
}
/**
 * Require field object to not be empty.
 */


function notEmpty$1(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message24;

      invalid(Object.keys(value).length > 0, (_options$message24 = options.message) !== null && _options$message24 !== void 0 ? _options$message24 : 'Object cannot be empty.', path, value);
    }

  };
}
/**
 * Require field object values to be of a specific schema type.
 * Will rebuild the object and type cast values.
 */


function of$3(state, valuesSchema) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isSchema(valuesSchema), 'A schema is required for object values.');
  }

  state.type += `<${valuesSchema.type()}>`;
  return {
    validate(value, path, validateOptions) {
      if (!isObject(value)) {
        return {};
      }

      const nextValue = _objectSpread({}, value);

      Object.keys(value).forEach(baseKey => {
        const key = baseKey;
        nextValue[key] = valuesSchema.validate(value[key], path ? `${path}.${key}` : String(key), validateOptions);
      });
      return nextValue;
    }

  };
}
/**
 * Require field object to be of a specific size.
 */


function sizeOf(state, size, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof size === 'number' && size > 0, 'Size of requires a non-zero positive number.');
  }

  return {
    validate(value, path) {
      var _options$message25;

      const _Object$keys = Object.keys(value),
            length = _Object$keys.length;

      invalid(length === size, (_options$message25 = options.message) !== null && _options$message25 !== void 0 ? _options$message25 : size === 1 ? `Object must have ${size} property, received ${length}.` : `Object must have ${size} properties, received ${length}.`, path, value);
    }

  };
}

const objectCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  keysOf: keysOf,
  notEmpty: notEmpty$1,
  of: of$3,
  sizeOf: sizeOf
});
/**
 * Require a shape to be an exact. No more and no less of the same properties.
 */

function exact(state, value = true) {
  state.metadata.exact = value;
}
/**
 * Require field to be an object with every property being a schema type.
 * Will rebuild the object (if not a class instance) and type cast values.
 * @internal
 */


function of$2(state, schemas) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isObject(schemas) && Object.values(schemas).every(isSchema), 'An object of schemas are required for a blueprint.');
  }

  const types = Object.entries(schemas).map(([key, value]) => `${key}: ${value.type()}`);
  state.type += `<{ ${types.join(', ')} }>`;
  return {
    validate(value, path, validateOptions) {
      if (value) {
        invalid(isObject(value), 'Value passed to shape must be an object.', path, value);
      }

      const isPlainObject = value.constructor === Object;
      const unknown = isPlainObject ? _objectSpread({}, value) : {};
      const shape = {};
      const errors = [];

      const currentValidateOptions = _objectSpread(_objectSpread({}, validateOptions), {}, {
        currentObject: value
      });

      Object.keys(schemas).forEach(prop => {
        const key = prop;
        const schema = schemas[key];
        const schemaState = schema.state();
        const currentPath = path ? `${path}.${key}` : String(key);

        try {
          if (schemaState.required) {
            var _schemaState$metadata;

            invalid(key in value && value[key] !== undefined, (_schemaState$metadata = schemaState.metadata.requiredMessage) !== null && _schemaState$metadata !== void 0 ? _schemaState$metadata : 'Field is required and must be defined.', currentPath, undefined);
          }

          shape[key] = schema.validate(value[key], currentPath, currentValidateOptions);
        } catch (error) {
          if (error instanceof Error) {
            errors.push(error);
          }
        } // Delete the prop and mark it as known


        delete unknown[key];
      });

      if (errors.length > 0) {
        throw new ValidationError(errors, path, value);
      } // Handle unknown fields


      if (state.metadata.exact) {
        if (process.env.NODE_ENV !== "production") {
          logUnknown(unknown, path);
        }
      } else {
        Object.assign(shape, unknown);
      } // Dont replace class instance with plain objects


      return isPlainObject ? shape : value;
    }

  };
}

const shapeCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  exact: exact,
  of: of$2
});
/**
 * Require field value to contain a provided string.
 */

function contains(state, token, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(isValidString(token), 'Contains requires a non-empty token.');
  }

  return {
    validate(value, path) {
      var _options$index, _options$message26;

      invalid(value.includes(token, (_options$index = options.index) !== null && _options$index !== void 0 ? _options$index : 0), (_options$message26 = options.message) !== null && _options$message26 !== void 0 ? _options$message26 : `String does not include "${token}".`, path, value);
    }

  };
}
/**
 * Require field value to match a defined regex pattern.
 */


function match(state, pattern, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(pattern instanceof RegExp, 'Match requires a regular expression to match against.');
  }

  return {
    validate(value, path) {
      var _options$message27;

      invalid(!!value.match(pattern), `${(_options$message27 = options.message) !== null && _options$message27 !== void 0 ? _options$message27 : 'String does not match.'} (pattern "${pattern.source}")`, path, value);
    }

  };
}
/**
 * Require field value to be formatted in camel case (fooBar).
 */


function camelCase(state, options = {}) {
  return match(state, /^[a-z][a-zA-Z0-9]+$/u, _objectSpread({
    message: 'String must be in camel case.'
  }, options));
}
/**
 * Require field value to be formatted in kebab case (foo-bar).
 */


function kebabCase(state, options = {}) {
  return match(state, /^[a-z][a-z0-9-]+$/u, _objectSpread({
    message: 'String must be in kebab case.'
  }, options));
}
/**
 * Require field value to be formatted in pascal case (FooBar).
 */


function pascalCase(state, options = {}) {
  return match(state, /^[A-Z][a-zA-Z0-9]+$/u, _objectSpread({
    message: 'String must be in pascal case.'
  }, options));
}
/**
 * Require field value to be formatted in snake case (foo_bar).
 */


function snakeCase(state, options = {}) {
  return match(state, /^[a-z][a-z0-9_]+$/u, _objectSpread({
    message: 'String must be in snake case.'
  }, options));
}
/**
 * Require field value to not be an empty string.
 */


function notEmpty(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message28;

      invalid(isValidString(value), (_options$message28 = options.message) !== null && _options$message28 !== void 0 ? _options$message28 : 'String cannot be empty.', path, value);
    }

  };
}
/**
 * Require field value to be one of the provided strings.
 */


function oneOf(state, list, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(Array.isArray(list) && list.length > 0 && list.every(item => typeof item === 'string'), 'One of requires an array of strings.');
  }

  return {
    validate(value, path) {
      var _options$message29;

      invalid(list.includes(value), (_options$message29 = options.message) !== null && _options$message29 !== void 0 ? _options$message29 : `String must be one of: ${list.join(', ')}. Received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be all lower case.
 */


function lowerCase(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message30;

      invalid(value === value.toLocaleLowerCase(), (_options$message30 = options.message) !== null && _options$message30 !== void 0 ? _options$message30 : `String must be lower cased, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be all upper case.
 */


function upperCase(state, options = {}) {
  return {
    validate(value, path) {
      var _options$message31;

      invalid(value === value.toLocaleUpperCase(), (_options$message31 = options.message) !== null && _options$message31 !== void 0 ? _options$message31 : `String must be upper cased, received ${prettyValue(value)}.`, path, value);
    }

  };
}
/**
 * Require field value to be of a specific string length.
 */


function lengthOf(state, size, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof size === 'number' && size > 0, 'Length requires a non-zero positive number.');
  }

  return {
    validate(value, path) {
      var _options$message32;

      invalid(value.length === size, (_options$message32 = options.message) !== null && _options$message32 !== void 0 ? _options$message32 : `String length must be ${size}, received ${value.length}.`, path, value);
    }

  };
}

const stringCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  contains: contains,
  match: match,
  camelCase: camelCase,
  kebabCase: kebabCase,
  pascalCase: pascalCase,
  snakeCase: snakeCase,
  notEmpty: notEmpty,
  oneOf: oneOf,
  lowerCase: lowerCase,
  upperCase: upperCase,
  lengthOf: lengthOf
});
/**
 * Require field array items to be of a specific schema type.
 * Will rebuild the array and type cast values.
 * @internal
 */

function of$1(state, itemsSchemas) {
  if (process.env.NODE_ENV !== "production") {
    invariant(Array.isArray(itemsSchemas) && itemsSchemas.length > 0 && itemsSchemas.every(isSchema), 'A non-empty array of schemas are required for a tuple.');
  }

  state.type = `tuple<${itemsSchemas.map(item => item.type()).join(', ')}>`;
  return {
    validate(value, path, validateOptions) {
      invalid(Array.isArray(value) && value.length <= itemsSchemas.length, `Value must be a tuple with ${itemsSchemas.length} items, received ${value.length}.`, path, value);
      const errors = [];
      const items = itemsSchemas.map((item, i) => {
        try {
          return item.validate(value[i], `${path}[${i}]`, validateOptions);
        } catch (error) {
          if (error instanceof Error) {
            errors.push(error);
          }
        }

        return null;
      });

      if (errors.length > 0) {
        throw new ValidationError(errors, path, value);
      }

      return items;
    }

  };
}

const tupleCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  of: of$1
});
/**
 * Require field value to be one of a specific schema type.
 */

function of(state, schemas, options = {}) {
  if (process.env.NODE_ENV !== "production") {
    invariant(Array.isArray(schemas) && schemas.length > 0 && schemas.every(isSchema), 'A non-empty array of schemas are required for a union.');
  }

  state.type = schemas.map(item => item.type()).join(' | ');
  return {
    validate(value, path, validateOptions) {
      let nextValue = value;
      const allowedValues = schemas.map(schema => schema.type()).join(', ');
      const valueType = typeOf(value);
      const errors = []; // eslint-disable-next-line complexity

      const passed = schemas.some(schema => {
        const schemaType = schema.schema();

        if (schemaType === 'union') {
          invalid(false, 'Nested unions are not supported.', path);
        }

        try {
          if (valueType === schemaType || valueType === 'object/shape' && schemaType === 'object' || valueType === 'object/shape' && schemaType === 'shape' || valueType === 'array/tuple' && schemaType === 'array' || valueType === 'array/tuple' && schemaType === 'tuple' || schemaType === 'custom') {
            // Dont pass path so its not included in the error message
            nextValue = schema.validate(value, '', validateOptions);
            return true;
          }
        } catch (error) {
          if (error instanceof Error) {
            errors.push(error);
          }
        }

        return false;
      });

      if (!passed) {
        if (errors.length > 0) {
          throw new ValidationError(errors, path, value);
        } else {
          var _options$message33;

          invalid(false, (_options$message33 = options.message) !== null && _options$message33 !== void 0 ? _options$message33 : `Received ${valueType} but value must be one of: ${allowedValues}.`, path, value);
        }
      }

      return nextValue;
    }

  };
}

const unionCriteria = /*#__PURE__*/Object.freeze({
  __proto__: null,
  of: of
});
/**
 * Create a schema that validates a value is an array, and optionally validate its items.
 */

function array(defaultValue = []) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), arrayCriteria),
    cast: createArray,
    defaultValue,
    type: 'array'
  }, [{
    validate(value, path) {
      invalid(Array.isArray(value), `Must be an array, received ${typeOf(value)}.`, path, value);
    }

  }]);
}
/**
 * Create a schema that validates a value is an indexed object (implicit keys).
 */


function object(defaultValue) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), objectCriteria),
    cast: createObject,
    defaultValue: defaultValue !== null && defaultValue !== void 0 ? defaultValue : {},
    type: 'object'
  }, [{
    validate(value, path) {
      invalid(isObject(value), `Must be a plain object, received ${typeOf(value)}.`, path, value);
    }

  }]);
}
/**
 * Create a schema that validates a value is an indexed object (implicit keys).
 */


const record = object; // All schemas need a default value to operate correctly,
// but functions are a weird one. We want to verify that
// "this value is a function" without needing to return
// a default value (predicates, etc), but also sometimes
// return a default value when undefined is passed
// (option objects, etc). So by default (pun intended),
// this schema's default value is `undefined`.

/**
 * Create a schema that validates a value is a function.
 */

function func(defaultValue) {
  return createSchema({
    api: _objectSpread({}, commonCriteria),
    defaultValue,
    type: 'function'
  }, [{
    validate(value, path) {
      // Special case, even when undefinable. See note above!
      if (value !== undefined) {
        invalid(typeof value === 'function', `Must be a function, received ${typeOf(value)}.`, path, value);
      }

      return value;
    }

  }]);
}
/**
 * Create a schema that validates a value is a schema instance.
 */


function schema() {
  // This is similar to shape, but we want to control the validation
  const shape = createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), shapeCriteria),
    cast: createObject,
    type: 'shape'
  }, [{
    validate(value, path) {
      // Dont use `isSchema` and rely on the shape below
      invalid(isObject(value), `Must be a schema, received ${typeOf(value)}.`, path, value);
    }

  }]);
  return shape.of({
    schema: func().notNullable().notUndefinable().required(),
    state: func().notNullable().notUndefinable().required(),
    type: func().notNullable().notUndefinable().required(),
    validate: func().notNullable().notUndefinable().required()
  });
}
/**
 * Create a schema that validates a value is an indexed object of schemas.
 */


function blueprint()
/* infer */
{
  return object().of(schema().notNullable());
}
/**
 * Create a schema that validates a value is a boolean.
 */


function bool(defaultValue = false) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), booleanCriteria),
    cast: Boolean,
    defaultValue,
    type: 'boolean'
  }, [{
    validate(value, path) {
      invalid(typeof value === 'boolean', `Must be a boolean, received ${typeOf(value)}.`, path, value);
    }

  }]);
}
/**
 * Create a schema that validates a value based on a defined custom validator callback.
 */


function custom(validator, defaultValue) {
  return createSchema({
    api: _objectSpread({}, commonCriteria),
    defaultValue,
    type: 'custom'
  }).custom(validator);
}
/**
 * Create a schema that validates a value is a date.
 * Supports `Date` objects, an ISO-8601 string, or a UNIX timestamp
 */


function date(defaultValue) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), dateCriteria),
    cast: createDate,
    defaultValue: defaultValue !== null && defaultValue !== void 0 ? defaultValue : new Date(),
    type: 'date'
  }, [{
    validate(value, path) {
      const time = createDate(value);
      invalid(isValidDate(time), `Must be a string, number, or \`Date\` that resolves to a valid date, received ${typeOf(value)}.`, path, value);
      return time;
    }

  }]);
}
/**
 * Create a schema that validates a value is an instance of a class.
 */


function instance() {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), classCriteria),
    defaultValue: null,
    type: 'class'
  }, [state => ({
    validate(value, path) {
      let valueType = typeOf(value);

      if (valueType === 'class') {
        valueType = prettyValue(value);
      }

      invalid(isObject(value) && value.constructor !== Object, state.type === 'class' ? `Must be a class instance, received ${valueType}.` : `Must be an instance of \`${state.type}\`, received ${valueType}.`, path, value);
    }

  })]).nullable();
}
/**
 * Create a schema that defers evaluation of the schema until it's needed.
 * This is useful for recursive schemas.
 */


function lazy(factory, defaultValue) {
  if (process.env.NODE_ENV !== "production") {
    invariant(typeof factory === 'function', 'Lazy requires a schema factory function.');
  }

  return createSchema({
    api: _objectSpread({}, commonCriteria),
    defaultValue,
    type: 'lazy'
  }, [{
    validate(value, path, validateOptions) {
      const schema = factory(value);

      if (process.env.NODE_ENV !== "production") {
        invariant(isSchema(schema), 'Factory must return a schema.');
      }

      return schema.validate(value, path, validateOptions);
    }

  }]);
}

function cast$1(value) {
  return value === undefined ? 0 : Number(value);
}
/**
 * Create a schema that validates a value is a number.
 */


function number(defaultValue = 0) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), numberCriteria),
    cast: cast$1,
    defaultValue,
    type: 'number'
  }, [{
    validate(value, path) {
      invalid(typeof value === 'number', `Must be a number, received ${typeOf(value)}.`, path, value);
    }

  }]);
}
/**
 * Create a schema that validates a value is an auto-incrementing ID.
 */


function id() {
  return number().positive().int().notNullable().notUndefinable();
}
/**
 * Create a schema that validates a value is a regex pattern (instance of `RegExp`).
 */


function regex()
/* infer */
{
  return instance().of(RegExp);
}
/**
 * Create a schema that validates a value is a shaped object (explicit keys).
 */


function shape(blueprint) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), shapeCriteria),
    cast: createObject,
    type: 'shape'
  }, [{
    validate(value, path) {
      if (value === undefined) {
        // Will be built from its items
        return {};
      }

      invalid(isObject(value), `Must be a shaped object, received ${typeOf(value)}.`, path, value);
      return value;
    }

  }]).of(blueprint);
}

function cast(value) {
  return value === undefined ? '' : String(value);
}
/**
 * Create a schema that validates a value is a string.
 */


function string(defaultValue = '') {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), stringCriteria),
    cast,
    defaultValue,
    type: 'string'
  }, [{
    validate(value, path) {
      invalid(typeof value === 'string', `Must be a string, received ${typeOf(value)}.`, path, value);
    }

  }]);
}
/**
 * Create a schema that validates a value is a UUID (universally unique identifier).
 */
// eslint-disable-next-line no-magic-numbers


function uuid(version) {
  return string().notEmpty().match(new RegExp(`^([0-9a-f]{8}-[0-9a-f]{4}-[${version !== null && version !== void 0 ? version : '1-5'}][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})|([0]{8}-[0]{4}-[0]{4}-[0]{4}-[0]{12})$`, 'i')).notNullable().notUndefinable();
}
/**
 * Create a schema that validates a value is a tuple; an explicit list of types.
 */


function tuple(schemas) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), tupleCriteria),
    // @ts-expect-error Ignore this, it's safe
    cast: createArray,
    type: 'tuple'
  }, [{
    validate(value, path) {
      if (value === undefined) {
        // Will be built from its items
        return [];
      }

      invalid(Array.isArray(value), `Must be a tuple, received ${typeOf(value)}.`, path, value);
      return value;
    }

  }]).of(schemas);
}
/**
 * Create a schema that validates a value against a list of possible values.
 */


function union(defaultValue) {
  return createSchema({
    api: _objectSpread(_objectSpread({}, commonCriteria), unionCriteria),
    defaultValue,
    type: 'union'
  });
}

const index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  array: array,
  blueprint: blueprint,
  bool: bool,
  custom: custom,
  date: date,
  func: func,
  instance: instance,
  lazy: lazy,
  id: id,
  number: number,
  object: object,
  record: record,
  regex: regex,
  schema: schema,
  shape: shape,
  string: string,
  uuid: uuid,
  tuple: tuple,
  union: union
});
/**
 * Create a reusable predicate from a schema that validates a value to
 * return a boolean if no validation errors arise. If null or undefined
 * is returned, will return `false`, regardless of nullable or undefinable
 * state.
 */

function createPredicate(schema) {
  return value => {
    try {
      if (value == null) {
        throw new Error('Avoid null/undefined');
      }

      schema.validate(value);
    } catch {
      return false;
    }

    return true;
  };
}

function optimal(blueprint, baseOpts = {}) {
  const options = {};
  let schema = shape(blueprint);

  function configure(nextOpts) {
    if (!isObject(nextOpts)) {
      throw new TypeError('Optimal options must be a plain object.');
    }

    Object.assign(options, nextOpts);
    schema = schema.exact(!options.unknown);
  }

  configure(baseOpts);
  return {
    configure,

    validate(struct, validateOptions) {
      const object = struct;

      try {
        var _options$prefix;

        return schema.validate(struct, (_options$prefix = options.prefix) !== null && _options$prefix !== void 0 ? _options$prefix : '', _objectSpread(_objectSpread({}, validateOptions), {}, {
          currentObject: object,
          rootObject: object
        }));
      } catch (error) {
        throw new OptimalError([error], options);
      }
    }

  };
}

exports.OptimalError = OptimalError;
exports.ValidationError = ValidationError;
exports.array = array;
exports.arrayCriteria = arrayCriteria;
exports.blueprint = blueprint;
exports.bool = bool;
exports.booleanCriteria = booleanCriteria;
exports.classCriteria = classCriteria;
exports.commonCriteria = commonCriteria;
exports.createPredicate = createPredicate;
exports.createSchema = createSchema;
exports.custom = custom;
exports.date = date;
exports.dateCriteria = dateCriteria;
exports.func = func;
exports.id = id;
exports.instance = instance;
exports.lazy = lazy;
exports.number = number;
exports.numberCriteria = numberCriteria;
exports.object = object;
exports.objectCriteria = objectCriteria;
exports.optimal = optimal;
exports.record = record;
exports.regex = regex;
exports.schema = schema;
exports.schemas = index;
exports.shape = shape;
exports.shapeCriteria = shapeCriteria;
exports.string = string;
exports.stringCriteria = stringCriteria;
exports.tuple = tuple;
exports.tupleCriteria = tupleCriteria;
exports.union = union;
exports.unionCriteria = unionCriteria;
exports.uuid = uuid;
//# sourceMappingURL=index.js.map
