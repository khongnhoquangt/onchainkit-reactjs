import { ArgsErrorCode } from './ArgsError';
import { ParseError } from './ParseError';
import { AliasMap, LongOptionName, OptionConfig, OptionConfigMap, ParamConfig, ShortOptionName, ValueType } from './types';
import { ValidationError } from './ValidationError';
export declare class Checker {
    arg: string;
    argIndex: number;
    options: OptionConfigMap;
    parseErrors: ParseError[];
    validationErrors: ValidationError[];
    constructor(options: OptionConfigMap);
    checkCommandOrder(anotherCommand: string, providedCommand: string, paramsLength: number): void;
    checkNoInlineValue(inlineValue?: string): void;
    checkUnknownOption(option: LongOptionName | ShortOptionName): void;
    validateArityIsMet(option: LongOptionName, config: OptionConfig, value: ValueType): void;
    validateDefaultValue(option: LongOptionName, value: unknown, config: OptionConfig): void;
    validateChoiceIsMet(option: LongOptionName, config: OptionConfig, value: ValueType): void;
    validateCommandFormat(command: string): void;
    validateNumberCount(option: LongOptionName, config: OptionConfig): void;
    validateParsedOption(option: LongOptionName, config: OptionConfig, value: unknown): void;
    validateParsedParam(config: ParamConfig, value: unknown): void;
    validateParamOrder(configs: ParamConfig[]): void;
    validateRequiredParamNoDefault(config: ParamConfig): void;
    validateUniqueShortName(option: LongOptionName, short: ShortOptionName, map: AliasMap): void;
    logFailureError(code: ArgsErrorCode, args?: unknown[]): void;
    logFailure(message: string): void;
    logInvalidError(code: ArgsErrorCode, args?: unknown[], option?: LongOptionName): void;
    logInvalid(message: string, option?: LongOptionName): void;
}
//# sourceMappingURL=Checker.d.ts.map