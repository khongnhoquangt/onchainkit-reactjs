'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
const levenary = require('levenary');
const ArgsError = require('./ArgsError.cjs');
const constants = require('./constants.cjs');
const ParseError = require('./ParseError.cjs');
const ValidationError = require('./ValidationError.cjs');
const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};
const levenary__default = /*#__PURE__*/_interopDefault(levenary);
class Checker {
  constructor(options) {
    this.arg = '';
    this.argIndex = 0;
    this.options = void 0;
    this.parseErrors = [];
    this.validationErrors = [];
    this.options = options;
  }
  checkCommandOrder(anotherCommand, providedCommand, paramsLength) {
    if (providedCommand !== '') {
      this.logFailureError('COMMAND_PROVIDED', [providedCommand, anotherCommand]);
    } else if (paramsLength !== 0) {
      this.logFailureError('COMMAND_NOT_FIRST');
    }
  }
  checkNoInlineValue(inlineValue) {
    if (inlineValue !== undefined) {
      this.logFailureError('VALUE_NO_INLINE');
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
  checkUnknownOption(option) {
    const guess = levenary__default.default(option, Object.keys(this.options));
    if (guess) {
      this.logFailureError('OPTION_UNKNOWN_MORE', [option, guess]);
    } else {
      this.logFailureError('OPTION_UNKNOWN', [option]);
    }
  }
  validateArityIsMet(option, config, value) {
    if (!config.arity || !Array.isArray(value)) {
      return;
    }
    if (value.length > 0 && value.length !== config.arity) {
      this.logInvalidError('VALUE_INVALID_ARITY', [config.arity, value.length], option);
    }
  }
  validateDefaultValue(option, value, config) {
    if (config.multiple) {
      if (!Array.isArray(value)) {
        this.logInvalidError('VALUE_NON_ARRAY', [option], option);
      }
      return;
    }
    if (config.type === 'boolean' && typeof value !== 'boolean') {
      this.logInvalidError('VALUE_NON_BOOL', [option], option);
    }
    if (config.type === 'number' && typeof value !== 'number') {
      this.logInvalidError('VALUE_NON_NUMBER', [option], option);
    }
    if (config.type === 'string' && typeof value !== 'string') {
      this.logInvalidError('VALUE_NON_STRING', [option], option);
    }
  }
  validateChoiceIsMet(option, config, value) {
    if (value && Array.isArray(config.choices) && !config.choices.includes(value)) {
      this.logInvalidError('VALUE_INVALID_CHOICE', [config.choices.join(', '), value || '""'], option);
    }
  }
  validateCommandFormat(command) {
    if (!constants.COMMAND_FORMAT.test(command)) {
      this.logInvalidError('COMMAND_INVALID_FORMAT', [command]);
    }
  }
  validateNumberCount(option, config) {
    if (config.count && config.type !== 'number') {
      this.logInvalidError('OPTION_INVALID_COUNT_TYPE', [], option);
    }
  }
  validateParsedOption(option, config, value) {
    if (config.validate) {
      try {
        config.validate(value);
      } catch (error) {
        this.logInvalid(error.message, option);
      }
    }
  }
  validateParsedParam(config, value) {
    if (config.validate) {
      try {
        config.validate(value);
      } catch (error) {
        this.logInvalid(error.message);
      }
    }
    if (config.required && value === undefined) {
      this.logInvalidError('PARAM_REQUIRED', [config.label]);
    }
  }
  validateParamOrder(configs) {
    const optionals = [];
    configs.forEach(config => {
      if (config.required) {
        if (optionals.length > 0) {
          const labels = optionals.map(opt => `"${opt.label}"`);
          this.logInvalidError('PARAM_INVALID_ORDER', [labels.join(', '), config.label]);
        }
      } else {
        optionals.push(config);
      }
    });
  }
  validateRequiredParamNoDefault(config) {
    if (config.required && config.default !== undefined) {
      this.logInvalidError('PARAM_REQUIRED_NO_DEFAULT', [config.label]);
    }
  }
  validateUniqueShortName(option, short, map) {
    if (map[short]) {
      this.logInvalidError('SHORT_DEFINED', [short, map[short]], option);
    }
    if (short.length !== 1) {
      this.logInvalidError('SHORT_INVALID_CHAR', [short], option);
    }
  }
  logFailureError(code, args) {
    this.logFailure(new ArgsError.ArgsError(code, args).message);
  }
  logFailure(message) {
    this.parseErrors.push(new ParseError.ParseError(message, this.arg, this.argIndex));
  }
  logInvalidError(code, args, option) {
    this.logInvalid(new ArgsError.ArgsError(code, args).message, option);
  }
  logInvalid(message, option) {
    this.validationErrors.push(new ValidationError.ValidationError(message, option));
  }
}
exports.Checker = Checker;
//# sourceMappingURL=Checker.cjs.map
