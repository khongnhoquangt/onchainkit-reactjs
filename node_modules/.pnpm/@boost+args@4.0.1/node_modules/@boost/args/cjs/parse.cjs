'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
Object.defineProperty(exports, '__esModule', {
  value: true
});
const ArgsError = require('./ArgsError.cjs');
const Checker = require('./Checker.cjs');
const constants = require('./constants.cjs');
const debug = require('./debug.cjs');
const castValue = require('./helpers/castValue.cjs');
const createScope = require('./helpers/createScope.cjs');
const expandShortOption = require('./helpers/expandShortOption.cjs');
const formatValue = require('./helpers/formatValue.cjs');
const getDefaultValue = require('./helpers/getDefaultValue.cjs');
const isCommand = require('./helpers/isCommand.cjs');
const isLongOption = require('./helpers/isLongOption.cjs');
const isOptionLike = require('./helpers/isOptionLike.cjs');
const isShortOption = require('./helpers/isShortOption.cjs');
const isShortOptionGroup = require('./helpers/isShortOptionGroup.cjs');
const mapParserOptions = require('./helpers/mapParserOptions.cjs');
const processShortOptionGroup = require('./helpers/processShortOptionGroup.cjs');

/* eslint-disable complexity, no-continue */
// TERMINOLOGY
// command line - The entire line that encompasses the following parts.
// arg - Each type of argument (or part) passed on the command line, separated by a space.
// command - An optional "command" being ran that allows for branching functionality.
//    Sub-commands are separated with ":".
// option - An optional argument that requires a value(s). Starts with "--" (long) or "-" (short).
// flag - A specialized option that only supports booleans. Can be toggled on an off (default).
// param - An optional or required argument, that is not an option or option value,
//    Supports any raw value, and enforces a defined order.
// rest - All remaining arguments that appear after a stand alone "--".
//    Usually passed to subsequent scripts.
// scope - Argument currently being parsed.

// FEATURES
// Short name - A short name (single character) for an existing option or flag: --verbose, -v
// Option grouping - When multiple short options are passed under a single option: -abc
// Inline values - Option values that are immediately set using an equals sign: --foo=bar
// Group count - Increment a number each time a short option is found in a group: -vvv
// Arity count - Required number of argument values to consume for multiples.
// Choices - List of valid values to choose from. Errors otherwise.
/**
 * Parse a list of command line arguments (typically from `process.argv`) into an arguments
 * object. Will extract commands, options, flags, and params based on the defined parser options.
 */
function parse(argv, parserOptions) {
  const _parserOptions$comman = parserOptions.commands,
    commandConfigs = _parserOptions$comman === void 0 ? [] : _parserOptions$comman,
    _parserOptions$loose = parserOptions.loose,
    looseMode = _parserOptions$loose === void 0 ? false : _parserOptions$loose,
    optionConfigs = parserOptions.options,
    _parserOptions$params = parserOptions.params,
    paramConfigs = _parserOptions$params === void 0 ? [] : _parserOptions$params,
    _parserOptions$unknow = parserOptions.unknown,
    allowUnknown = _parserOptions$unknow === void 0 ? false : _parserOptions$unknow,
    _parserOptions$variad = parserOptions.variadic,
    allowVariadic = _parserOptions$variad === void 0 ? true : _parserOptions$variad;
  const checker = new Checker.Checker(optionConfigs);
  const options = {};
  const params = [];
  const rest = [];
  const unknown = {};
  const mapping = {};
  let command = '';
  let currentScope = null;
  debug.debug('Parsing arguments: %s', argv.join(' '));
  function commitScope() {
    if (!currentScope) {
      return;
    }
    const _currentScope = currentScope,
      name = _currentScope.name,
      value = _currentScope.value,
      finalValue = _currentScope.finalValue;

    // Support loose mode
    if (looseMode) {
      options[name] = value === undefined ? !currentScope.negated : finalValue;

      // Set an unknown value
    } else if (currentScope.unknown) {
      if (allowUnknown) {
        unknown[name] = value === undefined ? constants.DEFAULT_STRING_VALUE : String(finalValue);
      }

      // Set and cast value if defined
    } else if (value !== undefined) {
      options[name] = finalValue;
    }
    currentScope = null;
  }

  // Run validations and map defaults
  checker.validateParamOrder(paramConfigs);
  mapParserOptions.mapParserOptions(parserOptions, options, params, {
    onCommand(cmd) {
      checker.validateCommandFormat(cmd);
    },
    onOption(config, value, name) {
      const short = config.short;
      if (short) {
        checker.validateUniqueShortName(name, short, mapping);
        mapping[short] = name;
      }
      options[name] = getDefaultValue.getDefaultValue(config);
      checker.validateDefaultValue(name, options[name], config);
      checker.validateNumberCount(name, config);
    },
    onParam(config) {
      checker.validateRequiredParamNoDefault(config);
    }
  });

  // Process each argument
  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    checker.arg = arg;
    checker.argIndex = i;

    // Rest arguments found, extract remaining and exit
    if (arg === '--') {
      rest.push(...argv.slice(i + 1));
      break;
    }
    try {
      // Options
      if (isOptionLike.isOptionLike(arg)) {
        let optionName = arg;
        let inlineValue;

        // Commit previous scope
        commitScope();

        // Extract option and inline value
        if (optionName.includes('=')) {
          var _optionName$split = optionName.split('=', 2);
          var _optionName$split2 = _slicedToArray(_optionName$split, 2);
          optionName = _optionName$split2[0];
          inlineValue = _optionName$split2[1];
        }

        // Short option group "-frl"
        if (isShortOptionGroup.isShortOptionGroup(optionName)) {
          checker.checkNoInlineValue(inlineValue);
          processShortOptionGroup.processShortOptionGroup(optionName.slice(1), optionConfigs, options, mapping, looseMode);
          continue;

          // Short option "-f"
        } else if (isShortOption.isShortOption(optionName)) {
          optionName = expandShortOption.expandShortOption(optionName.slice(1), mapping, looseMode);

          // Long option "--foo"
        } else if (isLongOption.isLongOption(optionName)) {
          optionName = optionName.slice(2);
        }

        // Parse and create next scope
        const scope = createScope.createScope(optionName, optionConfigs, options);

        // Unknown option found, handle accordingly
        if (scope.unknown && !allowUnknown && !looseMode) {
          checker.checkUnknownOption(arg);

          // Flag found, so set value immediately and discard scope
        } else if (scope.flag) {
          options[scope.name] = !scope.negated;
          checker.checkNoInlineValue(inlineValue);

          // Otherwise keep scope open, to capture next value
        } else {
          currentScope = scope;

          // Update scope value if an inline value exists
          if (inlineValue !== undefined) {
            currentScope.captureValue(inlineValue, commitScope);
          }
        }

        // Option values
      } else if (currentScope) {
        currentScope.captureValue(arg, commitScope);

        // Commands
      } else if (isCommand.isCommand(arg, commandConfigs)) {
        checker.checkCommandOrder(arg, command, params.length);
        if (!command) {
          command = arg;
        }

        // Params
      } else if (paramConfigs[params.length]) {
        const config = paramConfigs[params.length];
        params.push(formatValue.formatValue(castValue.castValue(arg, config.type), config.format));
      } else if (allowVariadic) {
        params.push(arg);
      } else {
        throw new ArgsError.ArgsError('PARAM_UNKNOWN', [arg]);
      }
    } catch (error) {
      currentScope = null;
      checker.logFailure(error.message);
      continue;
    }
  }

  // Commit final scope
  commitScope();

  // Fill missing params
  for (let i = params.length; i < paramConfigs.length; i += 1) {
    const config = paramConfigs[i];
    if (config.required) {
      break;
    }
    params.push(getDefaultValue.getDefaultValue(config));
  }

  // Run final checks
  mapParserOptions.mapParserOptions(parserOptions, options, params, {
    onOption(config, value, name) {
      checker.validateParsedOption(name, config, value);
      checker.validateArityIsMet(name, config, value);
      checker.validateChoiceIsMet(name, config, value);

      // Since default values avoid scope,
      // they are not cast. Do it manually after parsing.
      if (value === getDefaultValue.getDefaultValue(config)) {
        options[name] = castValue.castValue(value, config.type, config.multiple);
      }
    },
    onParam(config, value) {
      checker.validateParsedParam(config, value);
    }
  });
  return {
    command: command === '' ? [] : command.split(':'),
    errors: [...checker.parseErrors, ...checker.validationErrors],
    options: options,
    params: params,
    rest,
    unknown
  };
}
exports.parse = parse;
//# sourceMappingURL=parse.cjs.map
