'use strict';

const core = require('@babel/core');
function isWrappedWithConditional(path) {
  let currentPath = path;
  let wrapped = false;
  while (currentPath) {
    // Is there a cleaner way of doing this???
    if (currentPath.isIfStatement() && currentPath.get('test').isBinaryExpression({
      operator: '!=='
    }) && currentPath.get('test.left').isMemberExpression() && currentPath.get('test.left.object').isMemberExpression() && currentPath.get('test.left.object.object').isIdentifier({
      name: 'process'
    }) && currentPath.get('test.left.object.property').isIdentifier({
      name: 'env'
    }) && currentPath.get('test.left.property').isIdentifier({
      name: 'NODE_ENV'
    }) && currentPath.get('test.right').isStringLiteral({
      value: 'production'
    })) {
      wrapped = true;
      break;
    }
    currentPath = currentPath.parentPath;
  }
  return wrapped;
}
function conditionalInvariantPlugin() {
  return {
    visitor: {
      ExpressionStatement: {
        enter(path) {
          if (!path.get('expression').isCallExpression() || !path.get('expression.callee').isIdentifier({
            name: 'invariant'
          })) {
            return;
          }

          // Only transform invariants within the following scenarios:
          // 	- Block statements (if, while, functions, etc)
          // 	- Switch case statements
          //	- Module scope
          if (!path.parentPath.isBlockStatement() && !path.parentPath.isSwitchCase() && !path.parentPath.isProgram()) {
            return;
          }

          // Dont replace with new syntax if invariant is already wrapped
          // in a NODE_ENV conditional!
          if (isWrappedWithConditional(path)) {
            return;
          }
          path.replaceWith(core.types.ifStatement(core.types.binaryExpression('!==', core.types.memberExpression(core.types.memberExpression(core.types.identifier('process'), core.types.identifier('env'), false), core.types.identifier('NODE_ENV'), false), core.types.stringLiteral('production')), core.types.blockStatement([path.node])));
        }
      }
    }
  };
}
module.exports = conditionalInvariantPlugin;
//# sourceMappingURL=index.js.map
