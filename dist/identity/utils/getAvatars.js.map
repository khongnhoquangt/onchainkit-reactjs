{"version":3,"file":"getAvatars.js","sources":["../../../src/identity/utils/getAvatars.ts"],"sourcesContent":["import { getChainPublicClient } from '@/core/network/getChainPublicClient';\nimport { isBase } from '@/core/utils/isBase';\nimport { isEthereum } from '@/core/utils/isEthereum';\nimport type {\n  Basename,\n  GetAvatarReturnType,\n  GetAvatars,\n} from '@/identity/types';\nimport { mainnet } from 'viem/chains';\nimport { normalize } from 'viem/ens';\nimport { RESOLVER_ADDRESSES_BY_CHAIN_ID } from '../constants';\nimport { getBaseDefaultProfilePicture } from './getBaseDefaultProfilePicture';\nimport { isBasename } from './isBasename';\n\n/**\n * An asynchronous function to fetch multiple Basenames or Ethereum Name Service (ENS)\n * avatars for a given array of ENS names in a single batch request.\n * It returns an array of avatar URLs in the same order as the input names.\n */\nexport const getAvatars = async ({\n  ensNames,\n  chain = mainnet,\n}: GetAvatars): Promise<GetAvatarReturnType[]> => {\n  if (!ensNames || ensNames.length === 0) {\n    return [];\n  }\n\n  const chainIsBase = isBase({ chainId: chain.id });\n  const chainIsEthereum = isEthereum({ chainId: chain.id });\n  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;\n\n  if (!chainSupportsUniversalResolver) {\n    return Promise.reject(\n      'ChainId not supported, avatar resolution is only supported on Ethereum and Base.',\n    );\n  }\n\n  const results: GetAvatarReturnType[] = Array(ensNames.length).fill(null);\n\n  // Categorize names by type for optimized processing\n  const basenameIndices: number[] = [];\n  const normalIndices: number[] = [];\n\n  ensNames.forEach((name, index) => {\n    if (isBasename(name)) {\n      basenameIndices.push(index);\n    } else {\n      normalIndices.push(index);\n    }\n  });\n\n  // Process Base avatars\n  if (chainIsBase && basenameIndices.length > 0) {\n    const client = getChainPublicClient(chain);\n\n    try {\n      // Create batch of calls for Base avatars with individual error handling\n      const baseAvatarPromises = basenameIndices.map((index) =>\n        client\n          .getEnsAvatar({\n            name: normalize(ensNames[index]),\n            universalResolverAddress: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id],\n          })\n          .catch((error) => {\n            console.error(\n              `Error resolving Base avatar for ${ensNames[index]}:`,\n              error,\n            );\n            return null; // Return null for failed resolutions\n          }),\n      );\n\n      const baseAvatarResults = await Promise.all(baseAvatarPromises);\n\n      baseAvatarResults.forEach((avatar, i) => {\n        const originalIndex = basenameIndices[i];\n        if (avatar) {\n          results[originalIndex] = avatar;\n        }\n      });\n    } catch (error) {\n      console.error('Error resolving Base avatars in batch:', error);\n    }\n  }\n\n  // Process mainnet avatars\n  const fallbackClient = getChainPublicClient(mainnet);\n\n  try {\n    // Create batch of ENS avatar resolution calls with individual error handling\n    const ensAvatarPromises = ensNames.map((name, index) => {\n      // Skip if we already have a result\n      if (results[index] !== null) {\n        return Promise.resolve(null);\n      }\n      return fallbackClient\n        .getEnsAvatar({\n          name: normalize(name),\n        })\n        .catch((error) => {\n          console.error(`Error resolving ENS avatar for ${name}:`, error);\n          return null; // Return null for failed resolutions\n        });\n    });\n\n    // Execute all ENS avatar resolution calls\n    const ensAvatarResults = await Promise.all(ensAvatarPromises);\n\n    // Update results with ENS avatars\n    ensAvatarResults.forEach((avatar, index) => {\n      if (avatar && results[index] === null) {\n        results[index] = avatar;\n      }\n    });\n  } catch (error) {\n    console.error('Error resolving ENS avatars in batch:', error);\n  }\n\n  // Apply default Base profile pictures for basenames that don't have avatars\n  for (const index of basenameIndices) {\n    if (results[index] === null) {\n      results[index] = getBaseDefaultProfilePicture(\n        ensNames[index] as Basename,\n      );\n    }\n  }\n\n  return results;\n};\n"],"names":[],"mappings":";;;;;;;;AAmBO,MAAM,aAAa,OAAO;AAAA,EAC/B;AAAA,EACA,QAAQ;AACV,MAAkD;AAChD,MAAI,CAAC,YAAY,SAAS,WAAW,GAAG;AACtC,WAAO,CAAA;AAAA,EACT;AAEA,QAAM,cAAc,OAAO,EAAE,SAAS,MAAM,IAAI;AAChD,QAAM,kBAAkB,WAAW,EAAE,SAAS,MAAM,IAAI;AACxD,QAAM,iCAAiC,mBAAmB;AAE1D,MAAI,CAAC,gCAAgC;AACnC,WAAO,QAAQ;AAAA,MACb;AAAA,IAAA;AAAA,EAEJ;AAEA,QAAM,UAAiC,MAAM,SAAS,MAAM,EAAE,KAAK,IAAI;AAGvE,QAAM,kBAA4B,CAAA;AAGlC,WAAS,QAAQ,CAAC,MAAM,UAAU;AAChC,QAAI,WAAW,IAAI,GAAG;AACpB,sBAAgB,KAAK,KAAK;AAAA,IAC5B;AAAA,EAGF,CAAC;AAGD,MAAI,eAAe,gBAAgB,SAAS,GAAG;AAC7C,UAAM,SAAS,qBAAqB,KAAK;AAEzC,QAAI;AAEF,YAAM,qBAAqB,gBAAgB;AAAA,QAAI,CAAC,UAC9C,OACG,aAAa;AAAA,UACZ,MAAM,UAAU,SAAS,KAAK,CAAC;AAAA,UAC/B,0BAA0B,+BAA+B,MAAM,EAAE;AAAA,QAAA,CAClE,EACA,MAAM,CAAC,UAAU;AAChB,kBAAQ;AAAA,YACN,mCAAmC,SAAS,KAAK,CAAC;AAAA,YAClD;AAAA,UAAA;AAEF,iBAAO;AAAA,QACT,CAAC;AAAA,MAAA;AAGL,YAAM,oBAAoB,MAAM,QAAQ,IAAI,kBAAkB;AAE9D,wBAAkB,QAAQ,CAAC,QAAQ,MAAM;AACvC,cAAM,gBAAgB,gBAAgB,CAAC;AACvC,YAAI,QAAQ;AACV,kBAAQ,aAAa,IAAI;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,0CAA0C,KAAK;AAAA,IAC/D;AAAA,EACF;AAGA,QAAM,iBAAiB,qBAAqB,OAAO;AAEnD,MAAI;AAEF,UAAM,oBAAoB,SAAS,IAAI,CAAC,MAAM,UAAU;AAEtD,UAAI,QAAQ,KAAK,MAAM,MAAM;AAC3B,eAAO,QAAQ,QAAQ,IAAI;AAAA,MAC7B;AACA,aAAO,eACJ,aAAa;AAAA,QACZ,MAAM,UAAU,IAAI;AAAA,MAAA,CACrB,EACA,MAAM,CAAC,UAAU;AAChB,gBAAQ,MAAM,kCAAkC,IAAI,KAAK,KAAK;AAC9D,eAAO;AAAA,MACT,CAAC;AAAA,IACL,CAAC;AAGD,UAAM,mBAAmB,MAAM,QAAQ,IAAI,iBAAiB;AAG5D,qBAAiB,QAAQ,CAAC,QAAQ,UAAU;AAC1C,UAAI,UAAU,QAAQ,KAAK,MAAM,MAAM;AACrC,gBAAQ,KAAK,IAAI;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH,SAAS,OAAO;AACd,YAAQ,MAAM,yCAAyC,KAAK;AAAA,EAC9D;AAGA,aAAW,SAAS,iBAAiB;AACnC,QAAI,QAAQ,KAAK,MAAM,MAAM;AAC3B,cAAQ,KAAK,IAAI;AAAA,QACf,SAAS,KAAK;AAAA,MAAA;AAAA,IAElB;AAAA,EACF;AAEA,SAAO;AACT;"}