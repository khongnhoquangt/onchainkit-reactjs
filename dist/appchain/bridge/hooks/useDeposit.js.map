{"version":3,"file":"useDeposit.js","sources":["../../../../src/appchain/bridge/hooks/useDeposit.ts"],"sourcesContent":["'use client';\nimport { useAnalytics } from '@/core/analytics/hooks/useAnalytics';\nimport { AppchainEvent } from '@/core/analytics/types';\nimport { useCallback, useState } from 'react';\nimport { parseEther, parseUnits } from 'viem';\nimport type { Hex } from 'viem';\nimport { useAccount, useConfig, useSwitchChain, useWriteContract } from 'wagmi';\nimport { waitForTransactionReceipt } from 'wagmi/actions';\nimport { ERC20ABI, OptimismPortalABI, StandardBridgeABI } from '../abi';\nimport { EXTRA_DATA, MIN_GAS_LIMIT } from '../constants';\nimport type { UseDepositParams } from '../types';\nimport { isUserRejectedRequestError } from '../utils/isUserRejectedRequestError';\n\nexport function useDeposit() {\n  const { writeContractAsync, data } = useWriteContract();\n  const { switchChainAsync } = useSwitchChain();\n  const { chainId } = useAccount();\n  const wagmiConfig = useConfig();\n  const [status, setStatus] = useState<\n    'depositPending' | 'depositSuccess' | 'error' | 'idle' | 'depositRejected'\n  >('idle');\n  const { sendAnalytics } = useAnalytics();\n\n  const resetDepositStatus = useCallback(() => {\n    setStatus('idle');\n  }, []);\n\n  const deposit = async ({ config, from, bridgeParams }: UseDepositParams) => {\n    if (!bridgeParams.recipient) {\n      throw new Error('Recipient is required');\n    }\n\n    if (chainId !== from.id) {\n      await switchChainAsync({ chainId: from.id });\n    }\n\n    sendAnalytics(AppchainEvent.AppchainBridgeDepositInitiated, {\n      amount: bridgeParams.amount,\n      tokenAddress: bridgeParams.token.address,\n      recipient: bridgeParams.recipient,\n    });\n\n    setStatus('depositPending');\n\n    try {\n      // Native ETH\n      if (bridgeParams.token.address === '') {\n        const txHash = await writeContractAsync({\n          abi: StandardBridgeABI,\n          functionName: 'bridgeETHTo',\n          args: [bridgeParams.recipient, MIN_GAS_LIMIT, EXTRA_DATA],\n          address: config.contracts.l1StandardBridge,\n          value: parseEther(bridgeParams.amount),\n          chainId: from.id,\n        });\n\n        await waitForTransactionReceipt(wagmiConfig, {\n          hash: txHash,\n          confirmations: 1,\n          chainId: from.id,\n        });\n      } else {\n        // ERC20\n        if (!bridgeParams.token.remoteToken) {\n          throw new Error('Remote token address is required for ERC-20 tokens');\n        }\n\n        const formattedAmount = parseUnits(\n          bridgeParams.amount,\n          bridgeParams.token.decimals,\n        );\n\n        // Bridge address is OptimismPortal for depositing custom gas tokens\n        const bridgeAddress = bridgeParams.token.isCustomGasToken\n          ? config.contracts.optimismPortal\n          : config.contracts.l1StandardBridge;\n\n        // Approve the L1StandardBridge to spend tokens\n        const approveTx = await writeContractAsync({\n          abi: ERC20ABI,\n          functionName: 'approve',\n          args: [bridgeAddress, formattedAmount],\n          address: bridgeParams.token.address,\n        });\n        await waitForTransactionReceipt(wagmiConfig, {\n          hash: approveTx,\n          confirmations: 1,\n          chainId: from.id,\n        });\n\n        let bridgeTxHash: Hex;\n\n        // Bridge the tokens\n        if (bridgeParams.token.isCustomGasToken) {\n          bridgeTxHash = await writeContractAsync({\n            abi: OptimismPortalABI,\n            functionName: 'depositERC20Transaction',\n            args: [\n              bridgeParams.recipient,\n              formattedAmount,\n              formattedAmount,\n              BigInt(MIN_GAS_LIMIT),\n              false,\n              EXTRA_DATA,\n            ],\n            address: bridgeAddress,\n          });\n        } else {\n          bridgeTxHash = await writeContractAsync({\n            abi: StandardBridgeABI,\n            functionName: 'bridgeERC20To',\n            args: [\n              bridgeParams.token.address,\n              bridgeParams.token.remoteToken, // TODO: manually calculate the salted address\n              bridgeParams.recipient,\n              formattedAmount,\n              MIN_GAS_LIMIT,\n              EXTRA_DATA,\n            ],\n            address: bridgeAddress,\n          });\n        }\n\n        await waitForTransactionReceipt(wagmiConfig, {\n          hash: bridgeTxHash,\n          confirmations: 1,\n          chainId: from.id,\n        });\n      }\n\n      sendAnalytics(AppchainEvent.AppchainBridgeDepositSuccess, {\n        amount: bridgeParams.amount,\n        tokenAddress: bridgeParams.token.address,\n        recipient: bridgeParams.recipient,\n      });\n\n      setStatus('depositSuccess');\n    } catch (error) {\n      if (isUserRejectedRequestError(error)) {\n        console.error('User rejected request');\n        setStatus('depositRejected');\n      } else {\n        setStatus('error');\n        sendAnalytics(AppchainEvent.AppchainBridgeDepositFailure, {\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n  };\n\n  return {\n    deposit,\n    depositStatus: status,\n    transactionHash: data,\n    resetDepositStatus,\n  };\n}\n"],"names":[],"mappings":"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"}